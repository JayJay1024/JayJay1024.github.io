{"meta":{"title":"哼哼哈嘻","subtitle":"勿忘初心，保持平常心，从心出发","description":"哼哼哈嘻 | 留叶","author":"留叶","url":"https://damonlau27.github.io","root":"/"},"pages":[{"title":"404","date":"2016-09-03T05:14:17.000Z","updated":"2016-09-03T05:14:17.000Z","comments":true,"path":"404.html","permalink":"https://damonlau27.github.io/404.html","excerpt":"","text":"公益404页面 // 哼哼哈嘻"},{"title":"about","date":"2016-09-03T11:05:42.000Z","updated":"2016-09-03T11:05:42.000Z","comments":true,"path":"about/index.html","permalink":"https://damonlau27.github.io/about/index.html","excerpt":"","text":"我是谁，我从哪里来，我到哪里去？我就是我，是颜色不一样的吃货…"},{"title":"tags","date":"2020-01-02T16:31:47.533Z","updated":"2020-01-02T16:31:47.533Z","comments":true,"path":"tags/index.html","permalink":"https://damonlau27.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"jsx react-jsx error","slug":"jsx-react-jsx-error","date":"2020-12-23T08:15:47.000Z","updated":"2020-12-23T08:15:47.000Z","comments":true,"path":"2020/12/23/jsx-react-jsx-error/","link":"","permalink":"https://damonlau27.github.io/2020/12/23/jsx-react-jsx-error/","excerpt":"背景通过yarn create react-app antd-demo-ts --template typescript创建项目，使用VSCode打开项目提示错误：","text":"背景通过yarn create react-app antd-demo-ts --template typescript创建项目，使用VSCode打开项目提示错误： 问题VSCode使用的Typescript版本问题 解决VSCode选择使用工作区的版本","categories":[{"name":"攻城狮那些事儿","slug":"攻城狮那些事儿","permalink":"https://damonlau27.github.io/categories/%E6%94%BB%E5%9F%8E%E7%8B%AE%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"}],"tags":[]},{"title":"react+typescript+jest踩坑","slug":"react-typescript-jest踩坑","date":"2020-04-11T13:08:16.000Z","updated":"2020-04-11T13:08:16.000Z","comments":true,"path":"2020/04/11/react-typescript-jest踩坑/","link":"","permalink":"https://damonlau27.github.io/2020/04/11/react-typescript-jest%E8%B8%A9%E5%9D%91/","excerpt":"使用Typescript和一些配置package.jsonbabelConfig 用于告诉 ts-jest 是否使用 babel 。false不使用，true会查找 babel 配置文件，如 babel.config.json ，也可以配置某个具体的值。 identity-obj-proxy用于jest mock css module tsx 使用 babel-jest transform 遇到无法解析，后来改为使用 ts-jest 能解决问题","text":"使用Typescript和一些配置package.jsonbabelConfig 用于告诉 ts-jest 是否使用 babel 。false不使用，true会查找 babel 配置文件，如 babel.config.json ，也可以配置某个具体的值。 identity-obj-proxy用于jest mock css module tsx 使用 babel-jest transform 遇到无法解析，后来改为使用 ts-jest 能解决问题 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&#123; \"scripts\": &#123; \"dev\": \"webpack-dev-server --open\", \"test\": \"jest --no-cache\" &#125;, \"jest\": &#123; \"globals\": &#123; \"ts-jest\": &#123; \"babelConfig\": true &#125; &#125;, \"transform\": &#123; \"^.+\\\\.jsx?$\": \"babel-jest\", \"^.+\\\\.tsx?$\": \"ts-jest\" &#125;, \"transformIgnorePatterns\": [ \"&lt;rootDir&gt;/node_modules/?!(react-checkbox-group)\" ], \"moduleNameMapper\": &#123; \"\\\\.(css|less)$\": \"identity-obj-proxy\" &#125; &#125;, \"dependencies\": &#123; \"jest\": \"25.1.0\", \"react\": \"16.9.0\", \"react-checkbox-group\": \"^5.0.2\", \"react-dom\": \"16.9.0\" &#125;, \"devDependencies\": &#123; \"@babel/core\": \"^7.9.0\", \"@babel/preset-env\": \"^7.9.5\", \"@types/jest\": \"25.1.1\", \"@types/node\": \"12.7.2\", \"@types/pretty\": \"^2.0.0\", \"@types/react\": \"16.9.2\", \"@types/react-dom\": \"16.9.0\", \"@types/react-test-renderer\": \"^16.9.2\", \"babel-jest\": \"^25.3.0\", \"css-loader\": \"3.2.0\", \"html-webpack-plugin\": \"3.2.0\", \"identity-obj-proxy\": \"^3.0.0\", \"react-test-renderer\": \"^16.13.1\", \"source-map-loader\": \"0.2.4\", \"style-loader\": \"1.0.0\", \"ts-jest\": \"^25.3.1\", \"ts-loader\": \"6.0.4\", \"typescript\": \"3.6.2\", \"webpack\": \"4.39.3\", \"webpack-cli\": \"3.3.7\", \"webpack-dev-server\": \"3.8.0\" &#125;&#125; Jest Enable ES6Jest是Node环境，不能识别import/export等ES6语法，可以通过安装Babel解决 在项目根目录下建立babel.config.json文件，特别地，不要用.babelrc 填入： 12345&#123; \"presets\": [ [\"@babel/preset-env\", &#123;\"targets\": &#123;\"node\": \"current\"&#125;&#125;] ]&#125; 不要忘记： 1npm install @babel/preset-env --save-dev","categories":[{"name":"攻城狮那些事儿","slug":"攻城狮那些事儿","permalink":"https://damonlau27.github.io/categories/%E6%94%BB%E5%9F%8E%E7%8B%AE%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"}],"tags":[]},{"title":"《滚雪球--巴菲特和他的财富人生》","slug":"《滚雪球-巴菲特和他的财富人生》","date":"2020-02-15T13:49:47.000Z","updated":"2020-02-15T13:49:47.000Z","comments":true,"path":"2020/02/15/《滚雪球-巴菲特和他的财富人生》/","link":"","permalink":"https://damonlau27.github.io/2020/02/15/%E3%80%8A%E6%BB%9A%E9%9B%AA%E7%90%83-%E5%B7%B4%E8%8F%B2%E7%89%B9%E5%92%8C%E4%BB%96%E7%9A%84%E8%B4%A2%E5%AF%8C%E4%BA%BA%E7%94%9F%E3%80%8B/","excerpt":"巴拉巴拉这是一本巴菲特的传记，但不是那种作者连李嘉诚都没见过就写出的李嘉诚是怎么白手起家的传记。这本书很多是由巴菲特亲自口述，以及作者亲身观察巴菲特的工作，生活，他的朋友等，最后整理出来的。","text":"巴拉巴拉这是一本巴菲特的传记，但不是那种作者连李嘉诚都没见过就写出的李嘉诚是怎么白手起家的传记。这本书很多是由巴菲特亲自口述，以及作者亲身观察巴菲特的工作，生活，他的朋友等，最后整理出来的。 书中描述了巴菲特的家族情况，以时间线的形式，从巴菲特出生，童年，到后来的股神。 没读这本书之前，以为巴菲特家族是多么显赫，家庭是多么幸福，股神是多么的牛逼。但是读完之后就会发现，股神也是凡人。他的家族的人不是皇侯将相，他父亲做的小小的官也不如意，他怕他母亲和她聊不来。而巴菲特自己本身，小时候也不是特别自信不敢和女孩子说话，甚至有点内向家里热闹的时候就一个人躲到家里工作的地方一个人工作。唯一会让他滔滔不绝是讨论股票的时候。甚至除了投资，他的生活也需要别人照顾。 巴菲特非常“吝啬”，很在意钱，也没打算会给多少钱他的子女，所以他的子女不是像富二代那样每天体验生活。这也许和他觉得，今天的一美元一年后可以复利到十美元，所以才会十分吝啬钱。他没有把很多钱留给子女，而是把绝大部分捐献到盖茨夫妇的基金。 通过这本书看到了一个凡人版的股神，就和很多追星的一样，明星也是人，也是要吃喝拉撒的。 封面","categories":[{"name":"电影阅读","slug":"电影阅读","permalink":"https://damonlau27.github.io/categories/%E7%94%B5%E5%BD%B1%E9%98%85%E8%AF%BB/"}],"tags":[{"name":"读书","slug":"读书","permalink":"https://damonlau27.github.io/tags/%E8%AF%BB%E4%B9%A6/"}]},{"title":"为什么使用reflect","slug":"为什么使用reflect","date":"2020-01-09T12:41:13.000Z","updated":"2020-01-09T12:41:13.000Z","comments":true,"path":"2020/01/09/为什么使用reflect/","link":"","permalink":"https://damonlau27.github.io/2020/01/09/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8reflect/","excerpt":"前情Golang是一门静态语言，也就决定了一般情况下不能在程序运行中改变其行为。好在Golang也是一门面向反射的语言，通过反射机制，可以弥补这部分不足。","text":"前情Golang是一门静态语言，也就决定了一般情况下不能在程序运行中改变其行为。好在Golang也是一门面向反射的语言，通过反射机制，可以弥补这部分不足。 反射借用维基百科的一段话： 在计算机学中，反射（英语：reflection）是指计算机程序在运行时（runtime）可以访问、检测和修改它本身状态或行为的一种能力。用比喻来说，反射就是程序在运行的时候能够“观察”并且修改自己的行为。 Go中的反射reflect是Go的反射包。一个对象包含的最主要信息就是名称和值(key, value)，知道了名称和值，那么等于知道了对象的所有。 reflect中有两个重要的对象： type Value struct type Type interface 我们平时用到的reflect基本上都是围绕Type和Value。reflect提供可以获得这两个对象的方法： func TypeOf(i interface{}) Type func ValueOf(i interface{}) Value 得到Value和Type实例后，Value和Type提供很多方法供我们操作。 举例来说，我们可以通过reflect获取运行中某个变量是struct、interface还是func等类型，也可以获取变量的字段和值。 总之，通过reflect我们可以获取一个对象的一切，如果是struct，我们可以知道它的所有字段和值；如果是func，我们可以知道参数列表，然后构造一个函数，然后运行。","categories":[{"name":"攻城狮那些事儿","slug":"攻城狮那些事儿","permalink":"https://damonlau27.github.io/categories/%E6%94%BB%E5%9F%8E%E7%8B%AE%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://damonlau27.github.io/tags/Golang/"}]},{"title":"《正见》","slug":"《正见》","date":"2020-01-08T14:04:02.000Z","updated":"2020-01-08T14:04:02.000Z","comments":true,"path":"2020/01/08/《正见》/","link":"","permalink":"https://damonlau27.github.io/2020/01/08/%E3%80%8A%E6%AD%A3%E8%A7%81%E3%80%8B/","excerpt":"说些什么大佬分享的一本书，也许大概可能是自己境界不够，看得有点绕，看完有点云里雾里。","text":"说些什么大佬分享的一本书，也许大概可能是自己境界不够，看得有点绕，看完有点云里雾里。 封面","categories":[{"name":"电影阅读","slug":"电影阅读","permalink":"https://damonlau27.github.io/categories/%E7%94%B5%E5%BD%B1%E9%98%85%E8%AF%BB/"}],"tags":[{"name":"读书","slug":"读书","permalink":"https://damonlau27.github.io/tags/%E8%AF%BB%E4%B9%A6/"}]},{"title":"为什么要用Context(上下文)","slug":"Golang-Context","date":"2020-01-01T10:30:54.000Z","updated":"2020-01-01T10:30:54.000Z","comments":true,"path":"2020/01/01/Golang-Context/","link":"","permalink":"https://damonlau27.github.io/2020/01/01/Golang-Context/","excerpt":"写在前面相比在参数中传递用于控制流程的自定义管道变量，Context可以更方便地串联、管理多个Goroutine，在大型项目中发挥着重要的作用。","text":"写在前面相比在参数中传递用于控制流程的自定义管道变量，Context可以更方便地串联、管理多个Goroutine，在大型项目中发挥着重要的作用。 New ContextWithCancel1func WithCancel(parent Context) (ctx Context, cancel CancelFunc) 返回一个携带一个新的Done管道的parent副本，parent的cancel被执行或parent的Done被close的时候，副本的Done会被close。 12345678910111213141516171819func main() &#123; stoping := make(chan bool) ctx, cancel := context.WithCancel(context.Background()) go check(ctx, stoping) time.Sleep(3 * time.Second) fmt.Println(\"after 3s\") cancel() &lt;-stoping&#125;func check(ctx context.Context, stoping chan bool) &#123; fmt.Println(\"[check] start...\") &lt;-ctx.Done() fmt.Println(\"[check] end...\") stoping &lt;- true&#125; 输出： 123[check] start...after 3s[check] end... WithDeadline1func WithDeadline(parent Context, deadline time.Time) (Context, CancelFunc) 副本deadline或cancel的时候，或parent的Done被close的时候，副本的Done将close WithTimeout1func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc) 返回WithDeadline(parent, time.Now().Add(timeout))。 12345678910111213141516171819func main() &#123; ctx, _ := context.WithTimeout(context.Background(), 2*time.Second) go check(ctx, 1*time.Second) select &#123; case &lt;-ctx.Done(): fmt.Println(\"[main] \", ctx.Err()) &#125;&#125;func check(ctx context.Context, timeout time.Duration) &#123; select &#123; case &lt;-ctx.Done(): fmt.Println(\"[check] \", ctx.Err()) case &lt;-time.After(timeout): fmt.Println(\"[check] timeout\") &#125;&#125; 输出： 12[check] timeout[main] context deadline exceeded WithValue1func WithValue(parent Context, key interface&#123;&#125;, val interface&#123;&#125;) Context 123456789101112func main() &#123; stoping := make(chan bool) ctx := context.WithValue(context.Background(), \"name\", \"Jack\") go check(ctx, stoping) &lt;-stoping&#125;func check(ctx context.Context, stoping chan bool) &#123; fmt.Println(\"[check] Hi\", ctx.Value(\"name\")) stoping &lt;- true&#125; 输出： 1[check] Hi Jack BackgroundBackground returns a non-nil, empty Context. It is never canceled, has no values, and has no deadline。这个一般在main函数、初始化、测试和顶层使用，然后通过它往后派生。 TODO几乎是Background的别名般的存在，但相比Background，一些静态分析工具可以通过TODO分析Context有没有正确地传递。一般在对Context的使用还不清晰的地方使用。 Note Context被cancel的时候，关联的资源也会被释放 不要在struct中存储Context实例，明确地通过函数参数传递，并且一般作为第一个参数 即使函数运行，也不要传递nil Context，如果不确定传递的Context将来有什么用处，可以传递一个context.TODO 通过Context携带参数一般只用于请求域数据，可选参数应该明确通过函数参数传递 同一个Context可运行于不同Goroutines中的函数，Context可以在多个Goroutines间同步","categories":[{"name":"攻城狮那些事儿","slug":"攻城狮那些事儿","permalink":"https://damonlau27.github.io/categories/%E6%94%BB%E5%9F%8E%E7%8B%AE%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://damonlau27.github.io/tags/Golang/"}]},{"title":"C++碎碎念","slug":"C-碎碎念","date":"2019-11-25T10:22:52.000Z","updated":"2019-11-25T10:22:52.000Z","comments":true,"path":"2019/11/25/C-碎碎念/","link":"","permalink":"https://damonlau27.github.io/2019/11/25/C-%E7%A2%8E%E7%A2%8E%E5%BF%B5/","excerpt":"头文件中ifndef/define/endif的作用保证即使头文件被包含多次，也只定义一次，起到预编译保护作用。","text":"头文件中ifndef/define/endif的作用保证即使头文件被包含多次，也只定义一次，起到预编译保护作用。 extern “C”程序中的变量或函数，经C和C++编译器编译后后，符号不一样，会导致编译后的C代码在符号库中找不到。extern “C”告诉编译器这是C代码，按照C的方式编译。所以，extern “C”的目的是解决符号匹配问题，实现C和C++混合编程。 const和#define 都可以定义常量，const用途更广，比如修饰函数返回值和参数 const有数据类型，编译器可以对其进行类型安全检查，对#define只会进行字符替换 sizeof与strlen sizeof是运算符，strlen是函数 sizeof可以用类型做参数，strlen只能用\\0结尾的char * 指针和引用 定义指针时可以不初始化；定义引用时必须初始化 指针赋值是把指针指向另一个对象；引用赋值是修改引用绑定的对象的值在底层，引用变量由指针按照指针常量的方式实现，所以int i = 2;int* const gi = &amp;i;和int i = 2;int &amp;gi = i;是一致的。 空指针、野指针和悬垂指针 空指针：指向地址为空的指针(NULL指针)。可以被多次delete 野指针：指向垃圾内存的指针。产生原因是创建时未初始化，它将会随意指向一个内存地址 悬垂指针：动态创建的对象被释放或回收了，但是指向该对象的指针未做任何修改，仍旧指向已经回收的内存地址 malloc/free和new/delete malloc/free是C/C++标准库函数，new/delete是C++运算符 申请的是堆里面的内存空间 malloc不会做初始化，new有默认的初始化同时可以指定初始化。对于类类型而言，对象在创建的时候要自动执行构造函数，消亡之前要调用析构函数，malloc/free不能满足要求。malloc/free是库函数而不是运算符，不在编译器控制之内，不能把执行构造函数和析构函数的任务强加给它，因此，C++还需要malloc/free #pragma once和#ifndef/#define/#endif #pragma once是编译相关，某些编译器可能不能用，移植性差一些；#ifndef/#define/#endif是语言相关 #ifndef/#define/#endif依赖于宏名字不能冲突，这不光可以保证同一个文件不会被包含多次，也能保证内容完全相同的两个文件不会被不小心同时包含；缺点是如果不同头文件的宏名不小心“撞车”，可能会导致头文件明明存在，编译器却说找不到声明的状况 #pragma once由编译器提供保证同一个文件不会被包含多次。“同一个文件”是指物理上的一个文件，而不是指内容相同的两个文件，所以对应的缺点就是如果某个头文件有多份拷贝，将不能保证他们不被重复包含。当然，相比宏名碰撞引发的“找不到声明”的问题，重复包含更容易被发现并修正 NULL和nullptr在C中，NULL通常定义为#define NULL ((void *)0)，void *可以隐式转换成其他类型而C++是强类型的，void *不能隐式转换成其他指针类型，所以通常情况下编译器在头文件中会这样定义NULL： 12345#ifdef __cplusplus#define NULL 0#else#define NULL ((void *)0)#endif 所以C++中用0表示空指针。不过还是有缺陷不完美，处理重载函数的时候会出现问题。于是C++11引入了nullptr表示空指针 智能指针最主要是为了解决内存释放问题。对于一个大型项目，我们在这里申请了一块内存，而在离这里很远的各个地方需要我们释放这块内存的时候，我们常常忘记这个操作，而且有时发现问题还很难排查出来。智能指针的目的就是让程序自动销毁这块内存，而不是靠程序员手动销毁。(未完待续)","categories":[{"name":"攻城狮那些事儿","slug":"攻城狮那些事儿","permalink":"https://damonlau27.github.io/categories/%E6%94%BB%E5%9F%8E%E7%8B%AE%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"}],"tags":[]},{"title":"《简单实现自己的监听器模式》","slug":"《简单实现自己的监听器模式》","date":"2019-11-25T04:57:09.000Z","updated":"2019-11-25T04:57:09.000Z","comments":true,"path":"2019/11/25/《简单实现自己的监听器模式》/","link":"","permalink":"https://damonlau27.github.io/2019/11/25/%E3%80%8A%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%B7%B1%E7%9A%84%E7%9B%91%E5%90%AC%E5%99%A8%E6%A8%A1%E5%BC%8F%E3%80%8B/","excerpt":"实现监听器模式，不使用EventEmitter","text":"实现监听器模式，不使用EventEmitter 12345678910111213141516171819202122232425262728293031323334class MyEventEmitter &#123; constructor() &#123; this.handles &#x3D; Object.create(null); &#125; on(evt, cb) &#123; if (typeof cb !&#x3D;&#x3D; &#39;function&#39;) &#123; console.log(&#39;cb must be a function&#39;); return; &#125; if (!this.handles[evt]) &#123; this.handles[evt] &#x3D; []; &#125; this.handles[evt].push(cb); &#125; emit(evt, ...args) &#123; if (!!this.handles[evt]) &#123; this.handles[evt].forEach((item) &#x3D;&gt; &#123; Reflect.apply(item, this, args); &#125;); &#125; &#125;&#125;const emitter &#x3D; new MyEventEmitter();emitter.on(&#39;say&#39;, (name) &#x3D;&gt; &#123; console.log(&#39;Hello, &#39;, name);&#125;);setTimeout(() &#x3D;&gt; &#123; emitter.emit(&#39;say&#39;, &#39;Jay&#39;);&#125;, 1500);","categories":[{"name":"攻城狮那些事儿","slug":"攻城狮那些事儿","permalink":"https://damonlau27.github.io/categories/%E6%94%BB%E5%9F%8E%E7%8B%AE%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"}],"tags":[]},{"title":"Object.create(null)和{}","slug":"Object-create-null-和","date":"2019-11-25T03:10:00.000Z","updated":"2019-11-25T03:10:00.000Z","comments":true,"path":"2019/11/25/Object-create-null-和/","link":"","permalink":"https://damonlau27.github.io/2019/11/25/Object-create-null-%E5%92%8C/","excerpt":"let a = {}和let b = Object.create(null)有什么区别呢？","text":"let a = {}和let b = Object.create(null)有什么区别呢？ 在浏览器开发者工具查看console.log(a)和console.log(b)可以看到，a继承了Object的一些东西(基于原型链)，而b是干净的空的。 所以b的方式不用担心自己定义属性的话会和原型链上的冲突；另外某些循环中，不需要去遍历原型链上的属性，可以提升一丢丢性能。当然，这么做另一方面是丢掉了原型链上提供的所有属性或功能。 参考：https://juejin.im/post/5acd8ced6fb9a028d444ee4e","categories":[{"name":"攻城狮那些事儿","slug":"攻城狮那些事儿","permalink":"https://damonlau27.github.io/categories/%E6%94%BB%E5%9F%8E%E7%8B%AE%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"}],"tags":[]},{"title":"js实现继承","slug":"js实现继承","date":"2019-11-24T09:18:23.000Z","updated":"2019-11-24T09:18:23.000Z","comments":true,"path":"2019/11/24/js实现继承/","link":"","permalink":"https://damonlau27.github.io/2019/11/24/js%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF/","excerpt":"一、js继承问题es6引入了class和extends，从而可以像c++那样理解继承，但本质上这只是一个语法糖。","text":"一、js继承问题es6引入了class和extends，从而可以像c++那样理解继承，但本质上这只是一个语法糖。 123456789101112class Parent &#123; constructor(name) &#123; this.name &#x3D; name; &#125;&#125;class Children extends Parent &#123; constructor(name) &#123; super(name); &#x2F;&#x2F; 子类没有自己的this，不进行super，得不到继承自父类的this，将出错 &#125;&#125;const children &#x3D; new Children(&quot;children&quot;);console.log(children.name); &#x2F;&#x2F; children 二、自己如何实现继承12345678function Animal(color) &#123; this.name &#x3D; &quot;animal&quot;; this.color &#x3D; color; this.type &#x3D; [&#39;pic&#39;, &#39;cat&#39;];&#125;Animal.prototype.sayName &#x3D; function() &#123; console.log(&#96;Hey, I am $&#123;this.name&#125;&#96;);&#125; 1、继承方式1：原型链1234function Dog() &#123;&#125;Dog.prototype &#x3D; new Animal(&quot;white&quot;);const dog &#x3D; new Dog();console.log(dog.name, &quot;:&quot;, dog.color); &#x2F;&#x2F; animal : white 此种方式缺陷1：引用缺陷 1234const dog1 &#x3D; new Dog();dog1.type.push(&#39;dog&#39;);const dog2 &#x3D; new Dog();console.log(dog2.type); &#x2F;&#x2F; [ &#39;pic&#39;, &#39;cat&#39;, &#39;dog&#39; ] 此种方式缺陷2：对于继承来的属性，无法为不同的实例初始化为不同的值 12function Cat() &#123;&#125;Cat.prototype &#x3D; new Animal(&quot;black&quot;); &#x2F;&#x2F; 所有的Cat实例初始化时都是black色 2、继承方式2：借用构造函数(也叫经典继承)12345function Pic(color) &#123; Animal.apply(this, arguments);&#125;const pic &#x3D; new Pic(&quot;white&quot;);console.log(pic.name, &quot;:&quot;, pic.color); &#x2F;&#x2F; animal : white 此种方式缺陷：无法获取父类通过原型绑定的方法 1pic.sayName(); &#x2F;&#x2F; TypeError: pic.sayName is not a function 3、继承方式3：组合继承(就是组合上面两种，可以避免上面的缺陷。氮素，会调用两次父类构造函数)1234567function Monkey(color) &#123; Animal.apply(this, arguments);&#125;Monkey.prototype &#x3D; new Animal();const monkey &#x3D; new Monkey(&quot;gray&quot;);console.log(monkey.name, &quot;:&quot;, monkey.color); &#x2F;&#x2F; animal : graymonkey.sayName(); &#x2F;&#x2F; Hey, I am animal 4、继承方式4：寄生组合继承(避免调用两次父类构造函数的问题)12345function Tiger(color) &#123; Animal.apply(this, arguments);&#125;Tiger.prototype &#x3D; Object.create(Animal.prototype); &#x2F;&#x2F; 使用Object.create进行浅拷贝，少了一次调用父类的构造函数Tiger.prototype.constructor &#x3D; Tiger; &#x2F;&#x2F; 上面浅拷贝后Tiger.prototype的constructor被重写了，所以要修复一下","categories":[{"name":"攻城狮那些事儿","slug":"攻城狮那些事儿","permalink":"https://damonlau27.github.io/categories/%E6%94%BB%E5%9F%8E%E7%8B%AE%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"}],"tags":[]},{"title":"js的bind函数","slug":"js的bind函数","date":"2019-11-23T10:24:05.000Z","updated":"2019-11-23T10:24:05.000Z","comments":true,"path":"2019/11/23/js的bind函数/","link":"","permalink":"https://damonlau27.github.io/2019/11/23/js%E7%9A%84bind%E5%87%BD%E6%95%B0/","excerpt":"概述由Function.prototype.bind()，所以bind()是函数或方法的一个属性。bind()将创建一个新的函数，调用bind()的时候，新函数的this被bind()的第一个参数指定，bind()的其余参数将作为新函数的参数供调用时使用。","text":"概述由Function.prototype.bind()，所以bind()是函数或方法的一个属性。bind()将创建一个新的函数，调用bind()的时候，新函数的this被bind()的第一个参数指定，bind()的其余参数将作为新函数的参数供调用时使用。 123456789101112131415161718192021const obj &#x3D; &#123; x: 12, getX: function() &#123; return this.x; &#125;, setX: function(x) &#123; this.x &#x3D; x; &#125;&#125;console.log(obj.getX()); &#x2F;&#x2F; 12const unboundGetX &#x3D; obj.getX;&#x2F;&#x2F; console.log(unboundGetX()); &#x2F;&#x2F; TypeError: Cannot read property &#39;x&#39; of undefinedconst boundGetX &#x3D; unboundGetX.bind(obj);console.log(boundGetX()); &#x2F;&#x2F; 12const boundSetX &#x3D; obj.setX.bind(obj, 89);boundSetX(); &#x2F;&#x2F; 这时传不传参数不影响obj.x&#x3D;89的事实console.log(boundGetX()); &#x2F;&#x2F; 89const boundSetX2 &#x3D; obj.setX.bind(obj);boundSetX2(999); &#x2F;&#x2F; 这时如果不传参数obj.x将是undefinedconsole.log(boundGetX()); &#x2F;&#x2F; 999 实现自己的bind()12345678910111213141516171819202122232425262728293031const obj2 &#x3D; &#123; name: &quot;this is obj2&quot;&#125;function foo(color) &#123; console.log(color); return this.name;&#125;const bindFoo &#x3D; foo.bind(obj2, &quot;black&quot;);&#x2F;&#x2F; black&#x2F;&#x2F; this is obj2console.log(bindFoo());&#x2F;&#x2F; 构造函数时const nbfoo &#x3D; new bindFoo(); &#x2F;&#x2F; black，传入的参数依然生效console.log(nbfoo.name); &#x2F;&#x2F; undefined，传入的obj2失效，this指向的是nbfoo而不是obj2了&#x2F;&#x2F; TODO: new bindFoo()的时候，this指向的是new出来的而不是obj2，这个效果Function.prototype.mybind &#x3D; function(ctx) &#123; const fn &#x3D; this; const args &#x3D; Array.prototype.slice.call(arguments, 1); &#x2F;&#x2F; 去掉第0个 return function() &#123; return fn.apply(ctx, args); &#125;&#125;const mybindFoo &#x3D; foo.mybind(obj2, &quot;white&quot;);&#x2F;&#x2F; white&#x2F;&#x2F; this is obj2console.log(mybindFoo());","categories":[{"name":"攻城狮那些事儿","slug":"攻城狮那些事儿","permalink":"https://damonlau27.github.io/categories/%E6%94%BB%E5%9F%8E%E7%8B%AE%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"}],"tags":[]},{"title":"js的with关键字","slug":"js的with关键字","date":"2019-11-23T07:22:39.000Z","updated":"2019-11-23T07:22:39.000Z","comments":true,"path":"2019/11/23/js的with关键字/","link":"","permalink":"https://damonlau27.github.io/2019/11/23/js%E7%9A%84with%E5%85%B3%E9%94%AE%E5%AD%97/","excerpt":"使用1234567891011let obj &#x3D; &#123; a: &#39;aaa&#39;, b: &#39;bbb&#39;, c: &#39;ccc&#39;&#125;console.log(obj.a, obj.b, obj.c);&#x2F;&#x2F; 使用 withwith (obj) &#123; console.log(a, b, c);&#125;","text":"使用1234567891011let obj &#x3D; &#123; a: &#39;aaa&#39;, b: &#39;bbb&#39;, c: &#39;ccc&#39;&#125;console.log(obj.a, obj.b, obj.c);&#x2F;&#x2F; 使用 withwith (obj) &#123; console.log(a, b, c);&#125; with用来改变作用域，上面的a, b, c首先会被认为是局部变量，然后会查obj中有没有同名的，有就指向该同名属性 然而一般是不推荐使用with的，而且strict模式下是不能使用的，为什么呢？主要是性能问题，以及语意不明容易出现bug。 123456789101112131415161718192021222324252627282930let obj &#x3D; &#123; a: &#39;aaa&#39;, b: &#39;bbb&#39;, c: &#39;ccc&#39;&#125;function fn1() &#123; console.time(&quot;without&quot;); for (let i &#x3D; 0; i &lt; 10000; i++) &#123; let ta &#x3D; obj.a; let tb &#x3D; obj.b; let tc &#x3D; obj.c; &#125; console.timeEnd(&quot;without&quot;);&#125;function fn2() &#123; console.time(&quot;with&quot;); for (let i &#x3D; 0; i &lt; 10000; i++) &#123; with (obj) &#123; let ta &#x3D; a; let tb &#x3D; b; let tc &#x3D; c; &#125; &#125; console.timeEnd(&quot;with&quot;);&#125;fn1(); &#x2F;&#x2F; 0.343msfn2(); &#x2F;&#x2F; 6.114ms 因为js代码执行有一个编译阶段，使用with后js引擎不知道这些a, b, c是obj上的属性，无法对它们进行静态分析，就无法对这段代码进行优化；另外，一些js压缩工具也无法对这段代码进行压缩。这些是影响其性能的主要原因。 12345678910111213141516171819202122232425let objName &#x3D; &#123; name: &quot;apple&quot;&#125;let objColor &#x3D; &#123; color: &quot;white&quot;&#125;function foo(obj) &#123; with (obj) &#123; name &#x3D; &quot;dog&quot; &#125;&#125;&#x2F;&#x2F; console.log(name); &#x2F;&#x2F; 此时将出错，ReferenceError: name is not definedconsole.log(objName.name); &#x2F;&#x2F; applefoo(objName);console.log(objName.name); &#x2F;&#x2F; dogconsole.log(objColor.color); &#x2F;&#x2F; whitefoo(objColor);console.log(objColor.color); &#x2F;&#x2F; whiteconsole.log(objColor.name); &#x2F;&#x2F; undefinedconsole.log(name); &#x2F;&#x2F; dog 上面这段代码很容易出错和难以调试。","categories":[{"name":"攻城狮那些事儿","slug":"攻城狮那些事儿","permalink":"https://damonlau27.github.io/categories/%E6%94%BB%E5%9F%8E%E7%8B%AE%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"}],"tags":[]},{"title":"JS的call方法","slug":"JS的call方法","date":"2019-11-22T17:39:43.000Z","updated":"2019-11-22T17:39:43.000Z","comments":true,"path":"2019/11/23/JS的call方法/","link":"","permalink":"https://damonlau27.github.io/2019/11/23/JS%E7%9A%84call%E6%96%B9%E6%B3%95/","excerpt":"概述foo.call(this, args...)，指明foo函数或方法的this和参数，然后运行foo。","text":"概述foo.call(this, args...)，指明foo函数或方法的this和参数，然后运行foo。 12345678function Animal(name) &#123; console.log(&#96;animal&#39;s name is $&#123;name&#125;, color is $&#123;this.color&#125;&#96;);&#125;function Dog() &#123; this.color &#x3D; &quot;dog&#39;s color is white&quot;; Animal.call(this, &quot;dog&quot;);&#125;new Dog(); &#x2F;&#x2F; 打印 &quot;animal&#39;s name is dog, color is dog&#39;s color is white&quot; 为自己打call123456789101112131415161718192021222324252627Function.prototype.mycall &#x3D; function(ctx) &#123; &#x2F;&#x2F; ctx也就是传过来的this(同arguments[0])，传null则为window(nodejs可以用global) ctx &#x3D; ctx || (typeof window &#x3D;&#x3D;&#x3D; &quot;undefined&quot; ? global : window); ctx.foo &#x3D; this; &#x2F;&#x2F; 这个this是调用mycall的那个函数或方法 let args &#x3D; []; for (let i &#x3D; 1; i &lt; arguments.length; i++) &#123; args.push(arguments[i]); &#125; ctx.foo(...args); delete ctx.foo;&#125;function Animal2(name) &#123; console.log(&#96;animal&#39;s name is $&#123;name&#125;, color is $&#123;this.color&#125;&#96;);&#125;function Dog2() &#123; this.color &#x3D; &quot;black&quot;; Animal2.mycall(this, &quot;dogdog&quot;);&#125;new Dog2(); &#x2F;&#x2F; 打印 &quot;animal&#39;s name is dogdog, color is black&quot;let Cat &#x3D; &#123; color: &quot;white&quot;&#125;Animal2.mycall(Cat, &quot;catcat&quot;); &#x2F;&#x2F; 打印 &quot;animal&#39;s name is catcat, color is white&quot; apply呢上面的call，调用的时候，需要对应每个参数，而apply一共只有两个参数，第一个和call是一样的，而第二个参数传的是参数数组，这用于不确定参数时很方便。 12345678910function fn(arg1, arg2) &#123; console.log.call(console, arg1, arg2);&#125;fn(&quot;what&quot;, 666); &#x2F;&#x2F; 打印 &quot;what 666&quot;function fn2() &#123; console.log.apply(console, arguments);&#125;fn2(12, &quot;haha&quot;, 1234); &#x2F;&#x2F; 打印 &quot;12 haha 1234&quot;fn2(12, &quot;haha&quot;, 1234, &quot;what&quot;, &quot;why&quot;); &#x2F;&#x2F; 打印 &quot;12 haha 1234 what why&quot; 总的总的来说，call和apply都是为了动态改变this的指向。","categories":[{"name":"攻城狮那些事儿","slug":"攻城狮那些事儿","permalink":"https://damonlau27.github.io/categories/%E6%94%BB%E5%9F%8E%E7%8B%AE%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"}],"tags":[]},{"title":"JS原型和原型链","slug":"JS原型和原型链","date":"2019-11-22T15:23:07.000Z","updated":"2019-11-22T15:23:07.000Z","comments":true,"path":"2019/11/22/JS原型和原型链/","link":"","permalink":"https://damonlau27.github.io/2019/11/22/JS%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/","excerpt":"背景有时代码敲得再多，项目做的再多，面试时还是会被一些简单的问题难倒","text":"背景有时代码敲得再多，项目做的再多，面试时还是会被一些简单的问题难倒 JS原型和原型链读取某个属性，首先会在对象里面看看有没有，没有就会去对象的原型里面看看，以此直到最上层的Object对象的原型 1234567891011121314151617181920212223function Animal() &#123; &#x2F;&#x2F; 实例化后属于实例的属性 &#x2F;&#x2F; 如果这里不定义，则和 let animal &#x3D; new Animal(); animal.name &#x3D; &quot;I am an animal&quot; 是一样的 this.name &#x3D; &quot;I am an animal&quot;;&#125;Animal.prototype.name &#x3D; &quot;Hey, this is an animal&quot;; &#x2F;&#x2F; 对象原型的属性let animal &#x3D; new Animal();console.log(animal.name); &#x2F;&#x2F; 打印 &quot;I am an animal&quot;delete animal.name;console.log(animal.name); &#x2F;&#x2F; 打印 &quot;Hey, this is an animal&quot;console.log(animal.__proto__ &#x3D;&#x3D;&#x3D; Animal.prototype); &#x2F;&#x2F; trueconsole.log(Animal.prototype.__proto__ &#x3D;&#x3D;&#x3D; Object.prototype); &#x2F;&#x2F; true Animal的上一层是Objectconsole.log(Animal.prototype.constructor &#x3D;&#x3D;&#x3D; Animal); &#x2F;&#x2F; true&#x2F;&#x2F; 一般地let obj &#x3D; new Object();console.log(obj.__proto__ &#x3D;&#x3D;&#x3D; Object.prototype); &#x2F;&#x2F; trueconsole.log(Object.prototype.__proto__ &#x3D;&#x3D;&#x3D; null); &#x2F;&#x2F; true 原型链顶层console.log(Object.prototype.constructor &#x3D;&#x3D;&#x3D; Object); &#x2F;&#x2F; true","categories":[{"name":"攻城狮那些事儿","slug":"攻城狮那些事儿","permalink":"https://damonlau27.github.io/categories/%E6%94%BB%E5%9F%8E%E7%8B%AE%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"}],"tags":[]},{"title":"《伟大的博弈》读后","slug":"《伟大的博弈》读后","date":"2019-11-15T13:31:47.000Z","updated":"2019-11-15T13:31:47.000Z","comments":true,"path":"2019/11/15/《伟大的博弈》读后/","link":"","permalink":"https://damonlau27.github.io/2019/11/15/%E3%80%8A%E4%BC%9F%E5%A4%A7%E7%9A%84%E5%8D%9A%E5%BC%88%E3%80%8B%E8%AF%BB%E5%90%8E/","excerpt":"《伟大的博弈》讲的是华尔街的历史，讲述了华尔街从无到有，讲述了华尔街经历的战乱、灾难、成长，讲述了资本市场的腥风血雨、跌宕起伏。长投学堂的小熊老师说看完这本书，你对我们A股股市的波动就不会感到惊讶，因为和华尔街相比，A股的波动真的算不上波动了。","text":"《伟大的博弈》讲的是华尔街的历史，讲述了华尔街从无到有，讲述了华尔街经历的战乱、灾难、成长，讲述了资本市场的腥风血雨、跌宕起伏。长投学堂的小熊老师说看完这本书，你对我们A股股市的波动就不会感到惊讶，因为和华尔街相比，A股的波动真的算不上波动了。 读完这本书后，我感觉有点喜欢上读历史了，这真的是本很有趣的书。","categories":[{"name":"电影阅读","slug":"电影阅读","permalink":"https://damonlau27.github.io/categories/%E7%94%B5%E5%BD%B1%E9%98%85%E8%AF%BB/"}],"tags":[{"name":"读书","slug":"读书","permalink":"https://damonlau27.github.io/tags/%E8%AF%BB%E4%B9%A6/"}]},{"title":"《聪明的投资者》读后","slug":"《聪明的投资者》读后","date":"2019-11-10T14:30:58.000Z","updated":"2019-11-10T14:30:58.000Z","comments":true,"path":"2019/11/10/《聪明的投资者》读后/","link":"","permalink":"https://damonlau27.github.io/2019/11/10/%E3%80%8A%E8%81%AA%E6%98%8E%E7%9A%84%E6%8A%95%E8%B5%84%E8%80%85%E3%80%8B%E8%AF%BB%E5%90%8E/","excerpt":"《聪明的投资者》是巴菲特的老师格雷厄姆出的一本书，巴菲特据说很少向别人推荐什么书，可能是很多书不能入他老人家的法眼吧，却唯独这一本是他非常推崇的。这本书也是长投学堂的小熊老师说读了很多次的书。","text":"《聪明的投资者》是巴菲特的老师格雷厄姆出的一本书，巴菲特据说很少向别人推荐什么书，可能是很多书不能入他老人家的法眼吧，却唯独这一本是他非常推崇的。这本书也是长投学堂的小熊老师说读了很多次的书。 这本书讲了积极性投资者和保守型投资者的投资策略，股票和债券的投资组合，安全边际等等投资理财知识。读完这本书的感觉就是，书里面说的很多人应该都懂，也许还要多读几遍，满满领会。","categories":[{"name":"电影阅读","slug":"电影阅读","permalink":"https://damonlau27.github.io/categories/%E7%94%B5%E5%BD%B1%E9%98%85%E8%AF%BB/"}],"tags":[{"name":"读书","slug":"读书","permalink":"https://damonlau27.github.io/tags/%E8%AF%BB%E4%B9%A6/"}]},{"title":"scatter交易missing required accounts","slug":"scatter交易missing-required-accounts","date":"2019-02-18T07:39:23.000Z","updated":"2019-02-18T07:39:23.000Z","comments":true,"path":"2019/02/18/scatter交易missing-required-accounts/","link":"","permalink":"https://damonlau27.github.io/2019/02/18/scatter%E4%BA%A4%E6%98%93missing-required-accounts/","excerpt":"概述：使用scatter js sdk发起一笔交易，请求scatter确认时，出现如下错误提示： 1Missing required accounts, repull the identity","text":"概述：使用scatter js sdk发起一笔交易，请求scatter确认时，出现如下错误提示： 1Missing required accounts, repull the identity 解决：需要添加权限选项{ authorization: [account.name@account.authority] }，比如 EOS 转账交易： 123456789eos.contract(&#39;eosio.token&#39;).then(contract &#x3D;&gt; &#123; contract.transfer( &#39;fromaccount1&#39;, &#39;toaccount111&#39;, &#39;1.0000 EOS&#39;, &#39;test&#39;, &#123; authorization: [&#39;fromaccount1@active&#39;] &#125; );&#125;);","categories":[],"tags":[{"name":"eosio","slug":"eosio","permalink":"https://damonlau27.github.io/tags/eosio/"}]},{"title":"eosio.token的transfer的memo长度","slug":"eosio-token的transfer的memo长度","date":"2019-02-18T07:07:12.000Z","updated":"2019-02-18T07:07:12.000Z","comments":true,"path":"2019/02/18/eosio-token的transfer的memo长度/","link":"","permalink":"https://damonlau27.github.io/2019/02/18/eosio-token%E7%9A%84transfer%E7%9A%84memo%E9%95%BF%E5%BA%A6/","excerpt":"概述：平时我们进行 EOS 币转账的时候，memo最多可以填多少个汉字、多少个英文字符呢？","text":"概述：平时我们进行 EOS 币转账的时候，memo最多可以填多少个汉字、多少个英文字符呢？ 官方eosio.token合约的transfer方法，memo被断言为长度小于等于256（eosio_assert( memo.size() &lt;= 256, &quot;memo has more than 256 bytes&quot; )），那么作为一名“专业”码农应该觉得可以输入纯英文字符最多256个，纯汉字减半，然鹅在链上跑的时候，并不是酱紫的。 敲黑板：在链上跑的时候，纯汉字最多可以输入85个，纯英文字符可以输入258个。每个汉字占用length为3。","categories":[],"tags":[{"name":"eosio","slug":"eosio","permalink":"https://damonlau27.github.io/tags/eosio/"}]},{"title":"transaction declares authority错误","slug":"transaction-declares-authority错误","date":"2019-02-18T06:09:32.000Z","updated":"2019-02-18T06:09:32.000Z","comments":true,"path":"2019/02/18/transaction-declares-authority错误/","link":"","permalink":"https://damonlau27.github.io/2019/02/18/transaction-declares-authority%E9%94%99%E8%AF%AF/","excerpt":"概述：push action 或者 transaction 的时候，出现类似以下错误： 1transaction declares authority &#39;&#123;&quot;actor&quot;:&quot;myaccount111&quot;,&quot;permission&quot;:&quot;active&quot;&#125;&#39;, but does not have signatures for it under a provided delay of 0 ms, provided permissions [&#123;&quot;actor&quot;:&quot;myaccount111&quot;,&quot;permission&quot;:&quot;eosio.code&quot;&#125;], and provided keys []","text":"概述：push action 或者 transaction 的时候，出现类似以下错误： 1transaction declares authority &#39;&#123;&quot;actor&quot;:&quot;myaccount111&quot;,&quot;permission&quot;:&quot;active&quot;&#125;&#39;, but does not have signatures for it under a provided delay of 0 ms, provided permissions [&#123;&quot;actor&quot;:&quot;myaccount111&quot;,&quot;permission&quot;:&quot;eosio.code&quot;&#125;], and provided keys [] 原因：检查部署myaccount111的合约代码，看看是不是使用了内联 action 或 defer ，这需要你的myaccount111具有eosio.code权限 解决：给myaccount111赋予eosio.code权限 12&#x2F;&#x2F; 这里 EOS5RZcioUTeXNWCUehqtSHpzcXEj4auyRQiD3qwsjCQjWqmH8Qgs 是你 myaccount111 的公钥$: cleos set account permission myaccount111 active &#39;&#123;&quot;threshold&quot;:1, &quot;keys&quot;:[&#123;&quot;key&quot;:&quot;EOS5RZcioUTeXNWCUehqtSHpzcXEj4auyRQiD3qwsjCQjWqmH8Qgs&quot;, &quot;weight&quot;:1&#125;], &quot;accounts&quot;: [&#123;&quot;permission&quot;:&#123;&quot;actor&quot;:&quot;myaccount111&quot;,&quot;permission&quot;:&quot;eosio.code&quot;&#125;,&quot;weight&quot;:1&#125;]&#125;&#39; owner -p myaccount111","categories":[],"tags":[{"name":"eosio","slug":"eosio","permalink":"https://damonlau27.github.io/tags/eosio/"}]},{"title":"节点rpc无法访问","slug":"节点rpc无法访问","date":"2019-02-18T05:39:45.000Z","updated":"2019-02-18T05:39:45.000Z","comments":true,"path":"2019/02/18/节点rpc无法访问/","link":"","permalink":"https://damonlau27.github.io/2019/02/18/%E8%8A%82%E7%82%B9rpc%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE/","excerpt":"概述：你通过config.ini配置了http-server-address = 0.0.0.0:8888，并且配置了插件plugin = eosio::http_plugin，假设你的 server 的公开 ip 为12.34.56.78，氮素cleos -u http://12.34.56.78:8888仍然无法访问你的节点 rpc。","text":"概述：你通过config.ini配置了http-server-address = 0.0.0.0:8888，并且配置了插件plugin = eosio::http_plugin，假设你的 server 的公开 ip 为12.34.56.78，氮素cleos -u http://12.34.56.78:8888仍然无法访问你的节点 rpc。 一些问题： 看看你的 server 安全组有没有允许8888端口的访问 在config.ini中配置http-alias = 12.34.56.78:8888试试看 然后重启 nodeos","categories":[],"tags":[{"name":"eosio","slug":"eosio","permalink":"https://damonlau27.github.io/tags/eosio/"}]},{"title":"eos合约action命名","slug":"eos合约action命名","date":"2019-02-18T03:53:32.000Z","updated":"2019-02-18T03:53:32.000Z","comments":true,"path":"2019/02/18/eos合约action命名/","link":"","permalink":"https://damonlau27.github.io/2019/02/18/eos%E5%90%88%E7%BA%A6action%E5%91%BD%E5%90%8D/","excerpt":"概述：EOS 中，合约的action对应合约 C++ 代码中的一个函数，如果你认为这个函数可以像传统 C++ 编码那样命名，那就错了。因为对应合约的action，所以有一些规则限制。","text":"概述：EOS 中，合约的action对应合约 C++ 代码中的一个函数，如果你认为这个函数可以像传统 C++ 编码那样命名，那就错了。因为对应合约的action，所以有一些规则限制。 出错：如果编译或执行合约的某个action，出现以下提示，说明action对应的函数命名不合规范： 1Name should be less than 13 characters and only contains the following symbol .12345abcdefghijklmnopqrstuvwxyz 规范：从出错提示知道，action对应的函数名，长度不能超过12个字符，并且只能由.12345abcdefghijklmnopqrstuvwxyz这些字符组成。","categories":[],"tags":[{"name":"eosio","slug":"eosio","permalink":"https://damonlau27.github.io/tags/eosio/"}]},{"title":"config.ini中的signature-provider","slug":"config-ini中的signature-provider","date":"2019-02-18T03:30:25.000Z","updated":"2019-02-18T03:30:25.000Z","comments":true,"path":"2019/02/18/config-ini中的signature-provider/","link":"","permalink":"https://damonlau27.github.io/2019/02/18/config-ini%E4%B8%AD%E7%9A%84signature-provider/","excerpt":"概述：如果你要部署一个 EOSIO 的出块节点，你可能会关心这个问题。如果不是，或者你只是部署一个普通节点，那你不用care这里说的。","text":"概述：如果你要部署一个 EOSIO 的出块节点，你可能会关心这个问题。如果不是，或者你只是部署一个普通节点，那你不用care这里说的。 signature-provider应该填哪对秘钥：在节点的配置文件config.ini中，signature-provider应该填哪一对秘钥呢？可能你会和刚开始的我一样，觉得应该填的是出块账号对应的 owner 或 active 的 key ，但其实这是不建议的，因为涉及到安全问题。其实你完全可以通过 cleos create key --to-console 出来一对key ，只要你注册出块节点的时候使用这个key，那么signature-provider你就可以使用这对key。即，只要保证signature-provider用的是注册时的就行，至于注册你用哪个，你爱用哪个用哪个。","categories":[],"tags":[{"name":"eosio","slug":"eosio","permalink":"https://damonlau27.github.io/tags/eosio/"}]},{"title":"eosio计算ram价格","slug":"eosio计算ram价格","date":"2019-02-18T03:02:19.000Z","updated":"2019-02-18T03:02:19.000Z","comments":true,"path":"2019/02/18/eosio计算ram价格/","link":"","permalink":"https://damonlau27.github.io/2019/02/18/eosio%E8%AE%A1%E7%AE%97ram%E4%BB%B7%E6%A0%BC/","excerpt":"首先获取多索引表rammarket的数据：12345678910111213141516$: cleos -u https:&#x2F;&#x2F;nodes.get-scatter.com:443 get table eosio eosio rammarket&#123; &quot;rows&quot;: [&#123; &quot;supply&quot;: &quot;10000000000.0000 RAMCORE&quot;, &quot;base&quot;: &#123; &quot;balance&quot;: &quot;70910488246 RAM&quot;, &quot;weight&quot;: &quot;0.50000000000000000&quot; &#125;, &quot;quote&quot;: &#123; &quot;balance&quot;: &quot;1722420.0326 EOS&quot;, &quot;weight&quot;: &quot;0.50000000000000000&quot; &#125; &#125; ], &quot;more&quot;: false&#125;","text":"首先获取多索引表rammarket的数据：12345678910111213141516$: cleos -u https:&#x2F;&#x2F;nodes.get-scatter.com:443 get table eosio eosio rammarket&#123; &quot;rows&quot;: [&#123; &quot;supply&quot;: &quot;10000000000.0000 RAMCORE&quot;, &quot;base&quot;: &#123; &quot;balance&quot;: &quot;70910488246 RAM&quot;, &quot;weight&quot;: &quot;0.50000000000000000&quot; &#125;, &quot;quote&quot;: &#123; &quot;balance&quot;: &quot;1722420.0326 EOS&quot;, &quot;weight&quot;: &quot;0.50000000000000000&quot; &#125; &#125; ], &quot;more&quot;: false&#125; 那么n KB的内存价格为：1n KB内存需要的EOS &#x3D; ( n * quote.balance ) &#x2F; ( n + base.balance &#x2F; 1024 )","categories":[],"tags":[{"name":"eosio","slug":"eosio","permalink":"https://damonlau27.github.io/tags/eosio/"}]},{"title":"eosio获取账号actions","slug":"eosio获取账号actions","date":"2019-02-18T02:33:21.000Z","updated":"2019-02-18T02:33:21.000Z","comments":true,"path":"2019/02/18/eosio获取账号actions/","link":"","permalink":"https://damonlau27.github.io/2019/02/18/eosio%E8%8E%B7%E5%8F%96%E8%B4%A6%E5%8F%B7actions/","excerpt":"概述：有时候我们使用别人的 rpc 地址，get actions的时候返回的是空： 123$: cleos -u https:&#x2F;&#x2F;别人的rpc.io get actions myaccount111# seq when contract::action &#x3D;&gt; receiver trx id... args&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;","text":"概述：有时候我们使用别人的 rpc 地址，get actions的时候返回的是空： 123$: cleos -u https:&#x2F;&#x2F;别人的rpc.io get actions myaccount111# seq when contract::action &#x3D;&gt; receiver trx id... args&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 这是因为，你使用的这个别人的 rpc 地址，他的 nodeos 没有打开filter-on配置，或者他只开了他需要监听的账号和 action ，这个时候，你就要另找 rpc 地址了。 配置自己的节点：如果你有自己的节点，你想用自己节点的 rpc 查找 actions ，应该怎么配置呢？当然，你可以在 config.ini 配置文件中，设置 filter-on = * ，这样会记录全网的所有账号，以及所有的 actions ，但是你要认识到这需要很大的服务器物理内存。如果你只需要记录账号myaccount111的transfer，你只用这样配置就好了：filter-on = myaccount111::transfer。","categories":[],"tags":[{"name":"eosio","slug":"eosio","permalink":"https://damonlau27.github.io/tags/eosio/"}]},{"title":"screen","slug":"screen","date":"2019-02-06T14:15:16.000Z","updated":"2019-02-06T14:15:16.000Z","comments":true,"path":"2019/02/06/screen/","link":"","permalink":"https://damonlau27.github.io/2019/02/06/screen/","excerpt":"简介：当我们远程登录服务器，正在执行某些操作，比如正在编译源代码到60%，如果因为网络等各种原因断开了与服务器的链接，那么编译过程可能会被中断，我们重新链接服务器时需要从从头进行编译。如果执行编译前使用了screen，链接断开时编译工作不会中断，重连后登录之前的screen会话，就可以回到当时的环境。","text":"简介：当我们远程登录服务器，正在执行某些操作，比如正在编译源代码到60%，如果因为网络等各种原因断开了与服务器的链接，那么编译过程可能会被中断，我们重新链接服务器时需要从从头进行编译。如果执行编译前使用了screen，链接断开时编译工作不会中断，重连后登录之前的screen会话，就可以回到当时的环境。 使用： screen -S XXX：创建名为XXX的后台会话 screnn -ls：查看所有后台会话 screen -r XXX：恢复名为XXX的后台会话 参考：http://www.cnblogs.com/mchina/archive/2013/01/30/2880680.html","categories":[],"tags":[]},{"title":"EOSIO笔记","slug":"EOSIO笔记","date":"2019-02-02T14:34:55.000Z","updated":"2019-02-02T14:34:55.000Z","comments":true,"path":"2019/02/02/EOSIO笔记/","link":"","permalink":"https://damonlau27.github.io/2019/02/02/EOSIO%E7%AC%94%E8%AE%B0/","excerpt":"","text":"action 对应的 function 返回值为 void 命名长度不能超过12位 命名须由 .12345abcdefghijklmnopqrstuvwxyz 构成","categories":[],"tags":[{"name":"eosio","slug":"eosio","permalink":"https://damonlau27.github.io/tags/eosio/"}]},{"title":"HomeBrew","slug":"HomeBrew","date":"2019-02-02T14:18:27.000Z","updated":"2019-02-02T14:18:27.000Z","comments":true,"path":"2019/02/02/HomeBrew/","link":"","permalink":"https://damonlau27.github.io/2019/02/02/HomeBrew/","excerpt":"HomeBrew：macOS下的homebrew相当于Linux下的apt-get，即包管理器","text":"HomeBrew：macOS下的homebrew相当于Linux下的apt-get，即包管理器 包卸载：这里以卸载 boost 为例： 123$: brew unlink boost$: brew unpin boost$: brew uninstall boost 包升级：这里以升级 mongodb 为例 1$: brew upgrade mongodb 查看服务：1$: brew services list 启动、停止、重启服务：1$: brew services start&#x2F;stop&#x2F;restart mongodb","categories":[],"tags":[{"name":"macOS","slug":"macOS","permalink":"https://damonlau27.github.io/tags/macOS/"},{"name":"HomeBrew","slug":"HomeBrew","permalink":"https://damonlau27.github.io/tags/HomeBrew/"}]},{"title":"创建一个react native项目","slug":"创建一个react-native项目","date":"2018-12-08T00:57:19.000Z","updated":"2018-12-08T00:57:19.000Z","comments":true,"path":"2018/12/08/创建一个react-native项目/","link":"","permalink":"https://damonlau27.github.io/2018/12/08/%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAreact-native%E9%A1%B9%E7%9B%AE/","excerpt":"一、打开模拟器（当然也可以使用真机）打开任意一个，或者新建一个Android Studio项目，然后启动模拟器。","text":"一、打开模拟器（当然也可以使用真机）打开任意一个，或者新建一个Android Studio项目，然后启动模拟器。 二、新建工程$: react-native init demo 三、启动工程$: react-native run-android","categories":[{"name":"攻城狮那些事儿","slug":"攻城狮那些事儿","permalink":"https://damonlau27.github.io/categories/%E6%94%BB%E5%9F%8E%E7%8B%AE%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"}],"tags":[{"name":"React","slug":"React","permalink":"https://damonlau27.github.io/tags/React/"}]},{"title":"EOSIO通过插件存储账号余额到Mongo","slug":"EOSIO通过插件存储账号余额到Mongo","date":"2018-12-03T14:36:33.000Z","updated":"2018-12-03T14:36:33.000Z","comments":true,"path":"2018/12/03/EOSIO通过插件存储账号余额到Mongo/","link":"","permalink":"https://damonlau27.github.io/2018/12/03/EOSIO%E9%80%9A%E8%BF%87%E6%8F%92%E4%BB%B6%E5%AD%98%E5%82%A8%E8%B4%A6%E5%8F%B7%E4%BD%99%E9%A2%9D%E5%88%B0Mongo/","excerpt":"通过mongo_db_plugin存储账号余额到mongodb我们这里以存储eosio.token的EOS余额为例，思路是在发生transfer的时候，我们捕获该action，然后更新双方的余额。","text":"通过mongo_db_plugin存储账号余额到mongodb我们这里以存储eosio.token的EOS余额为例，思路是在发生transfer的时候，我们捕获该action，然后更新双方的余额。 首先，在class mongo_db_plugin_impl中声明我们需要的变量和函数 123456789 static const std::string accounts_col; static const std::string pub_keys_col; static const std::string account_controls_col;++ &#x2F;&#x2F; for get currency balance+ mongocxx::collection _currency_balance; &#x2F;&#x2F; mongo集合的handle+ static const std::string currency_balance_col; &#x2F;&#x2F; 将存放mongo集合的名称+ chain_plugin* chain_plug_handle; &#x2F;&#x2F; chain_plugin 中 get_currency_balance 可以帮助我们获取余额信息+ void update_currency_balance( const chain::action_trace&amp; ); &#x2F;&#x2F; 我们的操作放到这里进行 给集合取名为currency_balance 12 const std::string mongo_db_plugin_impl::account_controls_col &#x3D; &quot;account_controls&quot;;+const std::string mongo_db_plugin_impl::currency_balance_col &#x3D; &quot;currency_balance&quot;; &#x2F;&#x2F; mongo中集合将显示的是这个 在mongo_db_plugin_impl::consume_blocks中初始化handle 12 _account_controls &#x3D; mongo_conn[db_name][account_controls_col];+ _currency_balance &#x3D; mongo_conn[db_name][currency_balance_col]; 在mongo_db_plugin_impl::init()中给集合定义一个索引 123456789 account_controls.create_index( bsoncxx::from_json( R&quot;xxx(&#123; &quot;controlling_account&quot; : 1 &#125;)xxx&quot; ));+ &#x2F;&#x2F; currency_balance index+ auto currency_balance &#x3D; mongo_conn[db_name][currency_balance_col];+ currency_balance.create_index( bsoncxx::from_json( R&quot;xxx(&#123; &quot;name&quot; : 1 &#125;)xxx&quot; )); &#x2F;&#x2F; name字段索引为升序+ currency_balance.create_index( bsoncxx::from_json( R&quot;xxx(&#123; &quot;balance&quot; : -1 &#125;)xxx&quot; )); &#x2F;&#x2F; balance字段索引为降序+ &#125; catch (...) &#123; handle_mongo_exception( &quot;create indexes&quot;, __LINE__ ); 在mongo_db_plugin::plugin_initialize中实例化chain_plug_handle 123456789 auto&amp; chain &#x3D; chain_plug-&gt;chain(); my-&gt;chain_id.emplace( chain.get_chain_id());+ &#x2F;&#x2F; 给 chain_plug_handle 实例化+ my-&gt;chain_plug_handle &#x3D; chain_plug;+ my-&gt;accepted_block_connection.emplace( chain.accepted_block.connect( [&amp;]( const chain::block_state_ptr&amp; bs ) &#123; my-&gt;accepted_block( bs ); &#125; )); 定义我们的update_currency_balance函数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849+void mongo_db_plugin_impl::update_currency_balance( const chain::action_trace&amp; atrace ) &#123;+ using namespace bsoncxx::types;+ using bsoncxx::builder::basic::kvp;+ using bsoncxx::builder::basic::make_document;++ auto receiver &#x3D; atrace.receipt.receiver;+ if ( atrace.act.account &#x3D;&#x3D; name(&quot;eosio.token&quot;) &amp;&amp; atrace.act.name &#x3D;&#x3D; name(&quot;transfer&quot;) ) &#123;+ chain_apis::read_only::get_currency_balance_params params &#x3D; chain_apis::read_only::get_currency_balance_params &#123;+ .code &#x3D; name(&quot;eosio.token&quot;),+ .account &#x3D; receiver,+ .symbol &#x3D; &quot;EOS&quot;,+ &#125;;++ chain_apis::read_only ro_api &#x3D; chain_plug_handle-&gt;get_read_only_api();+ vector&lt;asset&gt; asserts &#x3D; ro_api.get_currency_balance( params );+ if ( !asserts.empty() ) &#123;+ asset balance &#x3D; asserts.at(0);+ auto now &#x3D; std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(+ std::chrono::microseconds&#123;fc::time_point::now().time_since_epoch().count()&#125; );++ &#x2F;&#x2F; ilog( &quot;$&#123;a&#125;&#39;s balance: $&#123;b&#125;&quot;, (&quot;a&quot;, atrace.receipt.receiver.to_string())(&quot;b&quot;, balance.to_string()) );++ mongocxx::options::update update_opts&#123;&#125;;+ update_opts.upsert( true );++ const double balance_real &#x3D; balance.to_real();+ const string receiver_str &#x3D; receiver.to_string();++ auto update &#x3D; make_document(+ kvp( &quot;$set&quot;, make_document( kvp( &quot;name&quot;, receiver_str),+ kvp( &quot;balance&quot;, balance_real),+ kvp( &quot;createdAt&quot;, b_date&#123;now&#125; ))+ )+ );++ try &#123;+ if( !_currency_balance.update_one( make_document( kvp( &quot;name&quot;, receiver_str )), update.view(), update_opts )) &#123;+ EOS_ASSERT( false, chain::mongo_db_update_fail, &quot;Failed to insert account $&#123;n&#125;&quot;, (&quot;n&quot;, receiver));+ &#125;+ &#125; catch (...) &#123;+ handle_mongo_exception( &quot;update_currency&quot;, __LINE__ );+ &#125;+ &#125;+ &#125;+&#125;+ mongo_db_plugin_impl::mongo_db_plugin_impl() &#123; &#125; mongodb-wipe的时候，应该删除集合，在mongo_db_plugin_impl::wipe_database添加如下 12345678 auto pub_keys &#x3D; mongo_conn[db_name][pub_keys_col]; auto account_controls &#x3D; mongo_conn[db_name][account_controls_col];+ auto currency_balance &#x3D; mongo_conn[db_name][currency_balance_col]; pub_keys.drop(); account_controls.drop();+ currency_balance.drop(); ilog(&quot;done wipe_database&quot;); 准备好了之后，重新./eosio_build.sh，然后使用该nodeos重启节点(当然重启节点前需要配置好mongo插件，并且sudo mongod启动了mongo服务)。通过shell查看mongo结果： 123456789101112131415161718192021222324252627282930313233343536$ mongo&gt; show dbsEOS 0.093GB...&gt; use EOSswitched to db EOS&gt; show collectionsaccount_controlsaccountsaction_tracesblock_statesblockscurrency_balancepub_keystransaction_tracestransactions&#x2F;&#x2F; 通过上面show collections可以看到我们自定义的currency_balance集合了&#x2F;&#x2F; 按照balance降序显示&gt; db.currency_balance.find().sort(&#123;balance:-1&#125;).pretty()&#123; &quot;_id&quot; : ObjectId(&quot;5bf684f44549fee6d16a0888&quot;), &quot;name&quot; : &quot;eosio.stake&quot;, &quot;balance&quot; : 240020654.8, &quot;createdAt&quot; : ISODate(&quot;2018-11-22T10:52:39.140Z&quot;)&#125;&#123; &quot;_id&quot; : ObjectId(&quot;5bf684f64549fee6d16a2964&quot;), &quot;name&quot; : &quot;eosio.faucet&quot;, &quot;balance&quot; : 199999730, &quot;createdAt&quot; : ISODate(&quot;2018-11-22T10:51:18.982Z&quot;)&#125;...","categories":[{"name":"攻城狮那些事儿","slug":"攻城狮那些事儿","permalink":"https://damonlau27.github.io/categories/%E6%94%BB%E5%9F%8E%E7%8B%AE%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"}],"tags":[{"name":"eosio","slug":"eosio","permalink":"https://damonlau27.github.io/tags/eosio/"}]},{"title":"EOSIO的Mongo插件的使用","slug":"EOSIO的Mongo插件的使用","date":"2018-12-03T14:30:30.000Z","updated":"2018-12-03T14:30:30.000Z","comments":true,"path":"2018/12/03/EOSIO的Mongo插件的使用/","link":"","permalink":"https://damonlau27.github.io/2018/12/03/EOSIO%E7%9A%84Mongo%E6%8F%92%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"eosio提供了mongo插件，实现把数据导到mongo中，从而可以更加灵活的操作数据。配置（config.ini）12plugin &#x3D; eosio::mongo_db_pluginmongodb-uri &#x3D; mongodb:&#x2F;&#x2F;localhost:27017","text":"eosio提供了mongo插件，实现把数据导到mongo中，从而可以更加灵活的操作数据。配置（config.ini）12plugin &#x3D; eosio::mongo_db_pluginmongodb-uri &#x3D; mongodb:&#x2F;&#x2F;localhost:27017 本地启动mongo1$ sudo mongod 重启nodeos1$ nodeos --replay-blockchain --hard-replay-blockchain --mongodb-wipe mongo中查询12345678910111213141516171819202122232425$ mongo&gt; show dbsEOS 0.372GB...&gt; use EOSswitched to db EOS&gt; show tablesaccount_controlsaccountsaction_tracesblock_statesblockspub_keystransaction_tracestransactions&gt; db.accounts.find().pretty()&#123; &quot;_id&quot; : ObjectId(&quot;5bf3cfbf4f6371c75cdc8890&quot;), &quot;name&quot; : &quot;superoneiobp&quot;, &quot;createdAt&quot; : ISODate(&quot;2018-11-20T09:11:27.309Z&quot;)&#125;...","categories":[{"name":"攻城狮那些事儿","slug":"攻城狮那些事儿","permalink":"https://damonlau27.github.io/categories/%E6%94%BB%E5%9F%8E%E7%8B%AE%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"}],"tags":[{"name":"eosio","slug":"eosio","permalink":"https://damonlau27.github.io/tags/eosio/"}]},{"title":"MongoDB简单使用","slug":"MongoDB简单使用","date":"2018-12-03T14:24:50.000Z","updated":"2018-12-03T14:24:50.000Z","comments":true,"path":"2018/12/03/MongoDB简单使用/","link":"","permalink":"https://damonlau27.github.io/2018/12/03/MongoDB%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/","excerpt":"MongoDB简介MongoDB是一个基于分布式文件存储，介于关系型和非关系型的数据库。今天我们通过第三方平台（如Google等）可以很轻易地访问和抓取用户数据。用户的个人信息、社交网络、地理位置，用户生成的数据和用户操作日子已经成倍的增加。我们如果要对这些数据挖掘，那SQL数据库已经不适合这些应用了，NoSQL(即No Only SQL，MongoDB就是这种类型的数据库之一)数据库的发展却能很好的处理这些大数据。","text":"MongoDB简介MongoDB是一个基于分布式文件存储，介于关系型和非关系型的数据库。今天我们通过第三方平台（如Google等）可以很轻易地访问和抓取用户数据。用户的个人信息、社交网络、地理位置，用户生成的数据和用户操作日子已经成倍的增加。我们如果要对这些数据挖掘，那SQL数据库已经不适合这些应用了，NoSQL(即No Only SQL，MongoDB就是这种类型的数据库之一)数据库的发展却能很好的处理这些大数据。 MongoDB将数据存储为一个文档，数据结构有键值对(key=&gt;value)组成，类似于JSON对象，MongoDB中叫BSON(即序列化的二进制JSON)。 MacOS平台安装MongoDB官网提供了安装包：https://www.mongodb.com/download-center#community；也可以通过brew进行安装: 1234567$ sudo brew install mongodb&#x2F;&#x2F; 安装支持 TLS&#x2F;SSL 命令$ sudo brew install mongodb --with-openssl&#x2F;&#x2F; 安装最新开发版本$sudo brew install mongodb --devel MongoDB操作运行12345678&#x2F;&#x2F; 创建一个数据库存储目录$ sudo mkdir -p &#x2F;data&#x2F;db&#x2F;&#x2F; 启动 mongodb，默认数据库目录即为 &#x2F;data&#x2F;db$ sudo mongod&#x2F;&#x2F; 打开另一个终端连接刚启动的mongod服务$ mongo 操作(启动mongo连接数据库服务后)显示数据库12345&#x2F;&#x2F; 显示所有数据库列表&gt; show dbs&#x2F;&#x2F; 显示当前的数据库或集合&gt; db 使用mytest数据库，如果不存在则新建&gt; use mytest 删除mytest数据库12&gt; use mytest&gt; db.dropDatabase() 创建集合123456&#x2F;&#x2F; 在test数据库上创建一个叫kk的集合&gt; use test&gt; db.createCollection(&quot;kk&quot;)&#x2F;&#x2F; 或者插入数据的时候，也会自动创建集合&gt; db.kk.insert(&#123;&quot;name&quot; : &quot;hhily&quot;&#125;) 查看集合&gt; show collections 删除集合123&#x2F;&#x2F; 删除test数据库中叫kk的集合&gt; use test&gt; db.kk.drop() 插入文档12345678910&#x2F;&#x2F; 在runoob数据库col集合中插入一条文档&gt; use runoob&gt; db.col.insert(&#123;title: &#39;MongoDB 教程&#39;, description: &#39;MongoDB 是一个 Nosql 数据库&#39;, by: &#39;菜鸟教程&#39;, url: &#39;http:&#x2F;&#x2F;www.runoob.com&#39;, tags: [&#39;mongodb&#39;, &#39;database&#39;, &#39;NoSQL&#39;], likes: 100&#125;)&#x2F;&#x2F; 上面的插入中，如果col集合不存在，将新建 查询文档123&gt; db.col.find().pretty()&#x2F;&#x2F; or&gt; db.col.findOne().pretty() 更新文档&gt; db.col.updateOne({&#39;title&#39;:&#39;MongoDB 教程&#39;},{$set:{&#39;title&#39;:&#39;MongoDB&#39;}}) 删除文档db.col.deleteMany({&#39;title&#39;:&#39;MongoDB 教程&#39;})","categories":[{"name":"攻城狮那些事儿","slug":"攻城狮那些事儿","permalink":"https://damonlau27.github.io/categories/%E6%94%BB%E5%9F%8E%E7%8B%AE%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"}],"tags":[]},{"title":"eosio的multi_index","slug":"eosio的multi-index","date":"2018-06-05T14:26:46.000Z","updated":"2018-06-05T14:26:46.000Z","comments":true,"path":"2018/06/05/eosio的multi-index/","link":"","permalink":"https://damonlau27.github.io/2018/06/05/eosio%E7%9A%84multi-index/","excerpt":"概述 multi_index是eosio上的数据库管理接口，通过eosio::multi_index智能合约能够写入、读取和修改eosio数据库的数据 multi_index在eosio中的位置：eos/contracts/eosiolib/multi_index.hpp","text":"概述 multi_index是eosio上的数据库管理接口，通过eosio::multi_index智能合约能够写入、读取和修改eosio数据库的数据 multi_index在eosio中的位置：eos/contracts/eosiolib/multi_index.hpp eosio::multi_index来源于boost库的boost::multi_index eosio::multi_index在概念上和传统数据库的“表(table)”类似，数据“行(rows)”是独立的对象（通常是class对象或struct对象），数据“列(columns)”是对象的成员属性（class或struct的成员属性） eosio::multi_index提供和传统数据库的“键(key)”类似的成员属性，用于快速查找对象 eosio::multi_index支持主键(primary key)，但必须是唯一的无符号64位整型(uint64_t) eosio::multi_index按主键排序时，使用升序 eosio::multi_index允许使用自定义函数作为索引，但它的返回值是受限制的，只能是支持的键类型 multi_index表允许多索引排序，最多可以使用16个二级索引 二级索引作为multi_index表构造函数的一部分创建，不支持直接构建 multi_index迭代器可以双向迭代，即const_iterator或const_reverse_iterator 创建multi_index表 使用C++类(class)或结构体(struct)定义对象 在class或struct中，定义一个const成员函数：primary_key()，返回uint64_t类型的主键值 确定二级索引（最多支持16个），二级索引不局限于uint64_t，它支持更多类型123456二级索引支持的键类型： idx64：64位无符号整型键 idx128：128位无符号整型键 idx256：256位固定大小字典键 idx_double：双精度浮点键 idx_long_double：四倍精度浮点键 为每个二级索引定义extractor，即一个函数，用于从Multi-Index表的函数中获取键，这个函数会被indexed_by（后面会讲）用到 一个完整的multi_index表定义如下：12345678910111213141516&#x2F;&#x2F;定义address表，i64表示索引使用默认的uint64_t类型&#x2F;&#x2F;@abi table address i64struct address &#123; uint64_t account; string name; uint64_t phone; uint64_t liked; &#x2F;&#x2F;定义address表的主键 uint64_t primary_key() const &#123; return account; &#125; &#x2F;&#x2F;定义extractor，二级索引是phone uint64_t get_phone() const &#123;return phone; &#125; &#x2F;&#x2F;序列化 EOSLIB_SERIALIZE(address, (account)(name)(phone)(liked)) 使用multi_index表（一）.实例化1234567&#x2F;&#x2F; 第一个参数是表名（即address），第二个参数是表对象的类型（address），其余为可变参数Indices（二级索引），数量不能超过16个typedef eosio::multi_index&lt; N(address), address, indexed_by&lt;N(phone), const_mem_fun&lt;address, uint64_t, &amp;address::get_phone&gt;&gt;&gt; address_index;&#x2F;&#x2F; 构造函数，有两个参数uint64_t类型参数：code, scope&#x2F;&#x2F; code: 拥有这张multi_index表的账户，该账户拥有对合约数据的读写权限&#x2F;&#x2F; scope: code层级内的范围标识符address_index addresses(_self, _self); （二）.表的操作1. emplace 添加一个新对象（row）到表中const_iterator emplace( unit64_t payer, Lambda&amp;&amp; constructor ) 参数payer：为新对象使用的存储付费的账户constructor：lambda函数，可以让新创建的对象就地初始化 返回值返回一个新创建的对象的主键迭代器 前置条件payer是被当前Action授权的有效账户，允许为使用存储付费 操作结果带有唯一主键的新对象在multi-index表中被创建；这个对象会被序列化，然后写入表中；如果表不存在，则创建表。二级索引被更新，用以引用新添加的对象；如果二级索引表不存在，则创建它们。payer为创建新对象所使用的存储付费；如果multi-index表和二级索引表需要被创建，则payer为表的创建付费。 异常当前接收者（multi_index的code参数）不是表的拥有者时，抛出异常 2. erase 使用主键从表中删除现有对象（两种形式）const_iterator erase( const_iterator itr )void erase( const object_type&amp; obj ) 参数itr：指向待删除对象的迭代器obj：待删除对象的引用 返回值使用itr查找对象时，返回被删除对象之后的对象的指针 操作结果对象从表中删除，相关的存储被回收；表相关的二级索引被更新；退还被删除对象的payer所支付的存储费用和相关费用。 异常待删除对象不存在时、Action无权修改表数据时、给定迭代器无效时，抛出异常 3. modify 修改表中已存在的对象（两种形式）void modify( const_iterator itr, uint64_t payer, Lambda&amp;&amp; updater )void modify( const object_type &amp;obj, uint64_t payer, Lambda&amp;&amp; updater ) 参数itr：指向待更新对象的迭代器obj：待更新对象的引用payer：为更新数据付费的账户，为0表示更新数据的payer和创建时的payer相同updater：用于更新目标对象的lambda函数 前置条件itr指向的对象，或obj引用的对象是存在的payer是被当前Action授权的有效账户，允许为使用存储付费 操作结果更新后的对象被序列化，然后替换表中的现有对象；二级索引被更新，被更新对象的主键不变。payer为更新对象所使用的存储付费；如果payer和该对象现有的payer相同，只需要为现有对象和更新对象不同的部分付费，如果差额为负，还会退还费用；如果payer和该对象现有的payer不同，则会退还费用给现有的payer。 异常无效的前提条件下调用，会抛出异常，并中止执行当前接收者（multi_index的code参数）不是表的拥有者时，抛出异常 4. get 使用主键从表中查询已存在的对象const object_type&amp; get( uint64_t primary ) const 参数primary：要查询对象的主键值 返回值包含指定主键的对象的常量引用 异常没有任何对象与给定的主键匹配时，抛出异常 5. find 使用主键从表中查询已存在的对象const_iterator find( uint64_t primary ) const 参数primary：要查询对象的主键值 返回值返回一个查询到的对象的迭代器如果没有查询到指定对象，返回一个end迭代器 （三）.成员访问 获取拥有主表的账户名uint64_t get_code() const 在code下的范围id（scope id），在该范围内可以找到期望的主表实例uint64_t get_scope() const （四）. 不支持的C++特性 eosio::multi_index不支持拷贝构造函数（Copy constructor） eosio::multi_index不支持赋值运算符（Assignment operator） （五）.迭代器multi_index迭代器遵循C++迭代器模式，所有迭代器都是双向迭代，即const_iterator或const_reverse_iterator。迭代器可以被间接引用，以提供对multi_index表中对象的访问。 begin &amp; cbegin返回指向对象类型的、从最小主键值开始的迭代器const_iterator begin() constconst_iterator cbegin() const end &amp; cend返回指向虚拟行的迭代器，代表刚刚过去的最后一行，不能被间接引用；可以向后推进，不能向前推进。const_iterator end() constconst_iterator end() const rbegin &amp; crbegin返回和begin/cbegin类似的，但反向的迭代器const_iterator rbegin() constconst_iterator crbegin() const rend &amp; crend返回和end/cend类似的，但反向的迭代器const_iterator rend() constconst_iterator crend() const lower_bound查找大于等于给定主键值的对象const_iterator lower_bound( uint64_t primary ) const upper_bound查找大于给定主键值的对象const_iterator upper_bound( uint64_t primary ) const get_index返回一个适当类型的二级索引secondary_index get_index&lt;IndexName&gt;()secondary_index get_index&lt;IndexName&gt;() const iterator_to返回给定对象的迭代器const_iterator iterator_to( const object_type&amp; obj ) const indexed_byindexed_by结构体用于实例化multi_index表的索引indexed_by在multi_index.hpp中的定义如下： 1234567891011121314151617&#x2F;&#x2F; 参数IndexName是索引的名称，这个名称是base32编码后的64位整数，且需要符合EOS命名规范：&#x2F;&#x2F; 1. 最多13个字符，前12个字符只能是小写字母、0-5、“.”&#x2F;&#x2F; 2. 如果有第13个字符，则只能是小写字母a-p、“.”&#x2F;&#x2F; 参数Extractor是一个函数，用于从multi_index表的函数中获取键，返回一个二级索引类型或二级索引类型的引用template&lt;uint64_t IndexName, typename Extractor&gt;struct indexed_by &#123; enum constants &#123; index_name &#x3D; IndexName &#125;; typedef Extractor secondary_extractor_type;&#125;;&#x2F;&#x2F; 推荐使用eosio::const_mem_fun模板，它是boost::multi_index::const_mem_fun的类型别名，例子：&#x2F;&#x2F; multi\\_index表的名字是N(address), N是一个宏，可以把base32编码后的字符串转换为uint64_t&#x2F;&#x2F; multi\\_index表的对象类型是address&#x2F;&#x2F; multi\\_index通过名为N(phone)的二级索引进行检索&#x2F;&#x2F; const_mem_fun是一个用于address类型的键提取器（key extractor ）&#x2F;&#x2F; const_mem_fun提取的键类型是uint64_t，通过address::get_phone函数获取键eosio::multi_index&lt; N(address), address, indexed_by&lt;N(phone), const_mem_fun&lt;address, uint64_t, &amp;address::get_phone&gt;&gt;&gt; 完整例子 12345678910111213&#x2F;&#x2F;@abi actionvoid likebyphone(uint64_t phone) &#123; address_index addresses(_self, _self); auto phone_index &#x3D; addresses.get_index&lt;N(phone)&gt;(); auto itr &#x3D; phone_index.lower_bound(phone); for(; itr !&#x3D; phone_index.end() &amp;&amp; itr-&gt;phone &#x3D;&#x3D; phone; ++itr) &#123; phone_index.modify(itr, 0, [&amp;](auto&amp; address)&#123; eosio::print(&quot;Liking: &quot;, address.name.c_str(), &quot;\\n&quot;); address.liked++; &#125;); &#125;&#125; (六). 工具函数 available_primary_key返回一个可用（未使用）的主键值，用于主键严格自增的表，它不会被设置为自定义值uint64_t available_primary_key() const 参考 https://bihu.com/article/328856 https://bihu.com/article/334710","categories":[{"name":"攻城狮那些事儿","slug":"攻城狮那些事儿","permalink":"https://damonlau27.github.io/categories/%E6%94%BB%E5%9F%8E%E7%8B%AE%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"}],"tags":[{"name":"Blockchain","slug":"Blockchain","permalink":"https://damonlau27.github.io/tags/Blockchain/"}]},{"title":"说说eosio.token合约","slug":"说说eosio-token合约","date":"2018-05-15T02:55:39.000Z","updated":"2018-05-15T02:55:39.000Z","comments":true,"path":"2018/05/15/说说eosio-token合约/","link":"","permalink":"https://damonlau27.github.io/2018/05/15/%E8%AF%B4%E8%AF%B4eosio-token%E5%90%88%E7%BA%A6/","excerpt":"一、eosio.token合约的请用 使用账户 hily 部署系统的 eosio.token 合约 $ cleos set contract hily build/contracts/eosio.token -p hily","text":"一、eosio.token合约的请用 使用账户 hily 部署系统的 eosio.token 合约 $ cleos set contract hily build/contracts/eosio.token -p hily 使用账户 hily 创建 HH 币，发行总量100000个 $ cleos push action hily create ‘[“hily”,”100000.0000 HH”,1,1,1]’ -p hily 向账户 hily 空投100个 HH $ cleos push action hily issue ‘[“hily”,”100.0000 HH”,”memo”]’ -p hily 查询账户 hily 的余额 $ cleos get table hily hily accounts 从账户 hily 转账10 HH 给 jay $ cleos push action hily transfer ‘[“hily”,”jay”,”10.0000 HH”,”memo”]’ -p hily 查看账户 jay 的余额 $ cleos get table hily jay accounts 使用 hily 部署 token 合约后，可以像上面一样， hily 自己创建一个 HH 币，同时账户 jay 也可以创建他的 JAY 币 $ cleos push action hily create ‘[“jay”,”10000.0000 JAY”,1,1,1]’ -p hily 空投 jay 的 JAY 币到 jack 时，要注意命令中各个账户的使用 $ cleos push action hily issue ‘[“jack”,”20.0000 JAY”,”memo”]’ -p jay 这时查看 jack 账户时，可以看到拥有的 JAY 币余额 $ cleos get table hily jack accounts 如果 jack 除了拥有 JAY 币外，还有拥有其他币，则上面的命令的结果将会显示 jack 不同的币的余额。 二、问题 比如上面我们将会发行10000个 JAY 币，并且空投了20个到 jack 账户，那么我们如何获得 JAY 币的剩余发行量（10000 - 20 = 9980）？ 三、eosio.token源码分析构造函数：使用 hily 账户部署 token 合约时（ cleos set contract hily build/contracts/eosio.token -p hily ）， hily 将传给 self ，而该 self 传到父类 contract 中时，将会存到到父类的 _self 属性中。 1token( account_name self ):contract(self)&#123;&#125; create函数：创建加密币，对应到这个命令 cleos push action hily create &#39;[&quot;hily&quot;,&quot;100000.0000 HH&quot;,1,1,1]&#39; -p hily 。 12345678910111213141516171819202122232425262728void token::create( account_name issuer, asset maximum_supply, uint8_t issuer_can_freeze, uint8_t issuer_can_recall, uint8_t issuer_can_whitelist )&#123; &#x2F;&#x2F; 这里的 _self 就是部署合约时的 hily ，所以上面的 create 命令需要加上 &quot;-p hily&quot; require_auth( _self ); auto sym &#x3D; maximum_supply.symbol; eosio_assert( sym.is_valid(), &quot;invalid symbol name&quot; ); &#x2F;&#x2F; 这里检查代币符合是否合法，比如上面的&quot;HH&quot; eosio_assert( maximum_supply.is_valid(), &quot;invalid supply&quot;); eosio_assert( maximum_supply.amount &gt; 0, &quot;max-supply must be positive&quot;); &#x2F;&#x2F; 这里检查代币的数量必须大于0，比如上面是100000.0000 stats statstable( _self, sym.name() ); auto existing &#x3D; statstable.find( sym.name() ); &#x2F;&#x2F; 根据代币的符号，比如上面命令中的&quot;HH&quot;，在合约中进行查找 eosio_assert( existing &#x3D;&#x3D; statstable.end(), &quot;token with symbol already exists&quot; ); &#x2F;&#x2F; 保证在这个合约中之前没有创建过这样的代币(&quot;HH&quot;) &#x2F;&#x2F; 把参数存放到statstable中 statstable.emplace( _self, [&amp;]( auto&amp; s ) &#123; s.supply.symbol &#x3D; maximum_supply.symbol; s.max_supply &#x3D; maximum_supply; s.issuer &#x3D; issuer; s.can_freeze &#x3D; issuer_can_freeze; s.can_recall &#x3D; issuer_can_recall; s.can_whitelist &#x3D; issuer_can_whitelist; &#125;);&#125; issue：空投或者发币cleos push action hily issue ‘[“jack“,”20.0000 JAY”,”memo”]’ -p jay 123456789101112131415161718192021222324252627282930313233void token::issue( account_name to, asset quantity, string memo )&#123; print( &quot;issue&quot; ); auto sym &#x3D; quantity.symbol; eosio_assert( sym.is_valid(), &quot;invalid symbol name&quot; ); &#x2F;&#x2F; 首先确保正确的代币 auto sym_name &#x3D; sym.name(); stats statstable( _self, sym_name ); auto existing &#x3D; statstable.find( sym_name ); eosio_assert( existing !&#x3D; statstable.end(), &quot;token with symbol does not exist, create token before issue&quot; ); &#x2F;&#x2F; 确保该代币，比如&quot;JAY&quot;，是存在的 const auto&amp; st &#x3D; *existing; require_auth( st.issuer ); &#x2F;&#x2F; 通过代币&quot;JAY&quot;找到对应的发行者是&quot;jay&quot;，所以上面的issue需要加上&quot;-p jay&quot; eosio_assert( quantity.is_valid(), &quot;invalid quantity&quot; ); eosio_assert( quantity.amount &gt; 0, &quot;must issue positive quantity&quot; ); eosio_assert( quantity.symbol &#x3D;&#x3D; st.supply.symbol, &quot;symbol precision mismatch&quot; ); eosio_assert( quantity.amount &lt;&#x3D; st.max_supply.amount - st.supply.amount, &quot;quantity exceeds available supply&quot;); &#x2F;&#x2F; 确保空投的数量不能超过剩余的可发行量 statstable.modify( st, 0, [&amp;]( auto&amp; s ) &#123; s.supply +&#x3D; quantity; &#125;); &#x2F;&#x2F; 这里有点意思，你会发现在这里jay账户会增加20 JAY，虽然上面的命令是空投20 JAY到jack账户 add_balance( st.issuer, quantity, st, st.issuer ); &#x2F;&#x2F; 到这里的时候，因为to是jack，st.issue是jay，所以不相等 if( to !&#x3D; st.issuer ) &#123; &#x2F;&#x2F; 这里call transfer的时候，就会先call sub_balance然后call sub_balance &#x2F;&#x2F; 实作就是把jay账户减去20（因为上面加了20到jay，而实际需要加到jack的），然后把jack账户增加20 JAY SEND_INLINE_ACTION( *this, transfer, &#123;st.issuer,N(active)&#125;, &#123;st.issuer, to, quantity, memo&#125; ); &#125;&#125; transfer：转账cleos push action hily transfer ‘[“jay”,”jack”,”10.0000 HH”,”memo”]’ -p jay 12345678910111213141516171819202122232425void token::transfer( account_name from, account_name to, asset quantity, string &#x2F;*memo*&#x2F; )&#123; print( &quot;transfer from &quot;, eosio::name&#123;from&#125;, &quot; to &quot;, eosio::name&#123;to&#125;, &quot; &quot;, quantity, &quot;\\n&quot; ); eosio_assert( from !&#x3D; to, &quot;cannot transfer to self&quot; ); &#x2F;&#x2F; 杜绝自己给自己转账，每个人都这么干将会造成EOS拥堵 require_auth( from ); &#x2F;&#x2F; 在这里就可以知道上面的命令为什么加上&quot;-p jay&quot;了 eosio_assert( is_account( to ), &quot;to account does not exist&quot;); &#x2F;&#x2F; 检查账户合法性 auto sym &#x3D; quantity.symbol.name(); stats statstable( _self, sym ); const auto&amp; st &#x3D; statstable.get( sym ); require_recipient( from ); require_recipient( to ); &#x2F;&#x2F; 检查转账的数量和代币正常性 eosio_assert( quantity.is_valid(), &quot;invalid quantity&quot; ); eosio_assert( quantity.amount &gt; 0, &quot;must transfer positive quantity&quot; ); eosio_assert( quantity.symbol &#x3D;&#x3D; st.supply.symbol, &quot;symbol precision mismatch&quot; ); &#x2F;&#x2F; 从from账户中减去指定的币额并加到to账户 sub_balance( from, quantity, st ); add_balance( to, quantity, st, from );&#125;","categories":[{"name":"攻城狮那些事儿","slug":"攻城狮那些事儿","permalink":"https://damonlau27.github.io/categories/%E6%94%BB%E5%9F%8E%E7%8B%AE%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"}],"tags":[{"name":"Blockchain","slug":"Blockchain","permalink":"https://damonlau27.github.io/tags/Blockchain/"}]},{"title":"nodeos与config.ini","slug":"nodeos与config-ini","date":"2018-05-08T08:15:11.000Z","updated":"2018-05-08T08:15:11.000Z","comments":true,"path":"2018/05/08/nodeos与config-ini/","link":"","permalink":"https://damonlau27.github.io/2018/05/08/nodeos%E4%B8%8Econfig-ini/","excerpt":"可能我们会通过这样的命令启动eos节点： 1$ nodeos -e -p eosio --plugin eosio::wallet_api_plugin --plugin eosio::chain_api_plugin --plugin eosio::account_history_api_plugin","text":"可能我们会通过这样的命令启动eos节点： 1$ nodeos -e -p eosio --plugin eosio::wallet_api_plugin --plugin eosio::chain_api_plugin --plugin eosio::account_history_api_plugin 如果不想每次启动都输入这么多参数，则可以通过配置对应的config.ini文件： “-e”对应的修改config.ini文件中12# Enable block production, even if the chain is stale. (eosio::producer_plugin)enable-stale-production &#x3D; true “-p eosio”对应12# ID of producer controlled by this node (e.g. inita; may specify multiple times) (eosio::producer_plugin)producer-name &#x3D; eosio “–plugin eosio::wallet_api_plugin –plugin eosio::chain_api_plugin –plugin eosio::account_history_api_plugin”对应123456# Plugin(s) to enable, may be specified multiple timesplugin &#x3D; eosio::producer_pluginplugin &#x3D; eosio::wallet_api_pluginplugin &#x3D; eosio::chain_api_pluginplugin &#x3D; eosio::account_history_api_pluginplugin &#x3D; eosio::http_plugin 配置好config文件，以后启动节点只需要nodeos命令就好了，不需要参数： 1$ nodeos","categories":[{"name":"攻城狮那些事儿","slug":"攻城狮那些事儿","permalink":"https://damonlau27.github.io/categories/%E6%94%BB%E5%9F%8E%E7%8B%AE%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"}],"tags":[{"name":"Blockchain","slug":"Blockchain","permalink":"https://damonlau27.github.io/tags/Blockchain/"}]},{"title":"合约编写部署和执行","slug":"合约编写部署和执行","date":"2018-05-07T13:23:35.000Z","updated":"2018-05-07T13:23:35.000Z","comments":true,"path":"2018/05/07/合约编写部署和执行/","link":"","permalink":"https://damonlau27.github.io/2018/05/07/%E5%90%88%E7%BA%A6%E7%BC%96%E5%86%99%E9%83%A8%E7%BD%B2%E5%92%8C%E6%89%A7%E8%A1%8C/","excerpt":"假设你已经安装了EOSIO并且启动了nodeos。 创建钱包12345$ cleos wallet create -n mywalletCreating wallet: mywalletSave password to use in the future to unlock this wallet.Without password imported keys will not be retrievable.&quot;PW5KTrGBhmMeDAZxM69PgZxcHXaT2aaebFRWriZq5PDshPUaowpJF&quot;","text":"假设你已经安装了EOSIO并且启动了nodeos。 创建钱包12345$ cleos wallet create -n mywalletCreating wallet: mywalletSave password to use in the future to unlock this wallet.Without password imported keys will not be retrievable.&quot;PW5KTrGBhmMeDAZxM69PgZxcHXaT2aaebFRWriZq5PDshPUaowpJF&quot; 使用钱包之前，需要解锁钱包： 12$ cleos wallet unlock --password PW5KTrGBhmMeDAZxM69PgZxcHXaT2aaebFRWriZq5PDshPUaowpJFUnlocked: default 上面的命令你的密码将会记录到shell历史中，更安全的，你可以通过下面的方法解锁： 12$ cleos wallet unlockpassword: 你不使用它的时候，锁定它是一个良好的习惯： 12$ cleos wallet lockLocked: default Bios关键的系统合约EOS相当于一个操作系统，而Bios就是这个系统的引导。进入到EOSIO的source code root目录下： 1234567$ cleos set contract eosio build&#x2F;contracts&#x2F;eosio.bios -p eosioReading WAST...Assembling WASM...Publishing contract...executed transaction: 414cf0dc7740d22474992779b2416b0eabdbc91522c16521307dd682051af083 4068 bytes 10000 cycles# eosio &lt;&#x3D; eosio::setcode &#123;&quot;account&quot;:&quot;eosio&quot;,&quot;vmtype&quot;:0,&quot;vmversion&quot;:0,&quot;code&quot;:&quot;0061736d0100000001ab011960037f7e7f0060057f7e7e7e...# eosio &lt;&#x3D; eosio::setabi &#123;&quot;account&quot;:&quot;eosio&quot;,&quot;abi&quot;:&#123;&quot;types&quot;:[],&quot;structs&quot;:[&#123;&quot;name&quot;:&quot;set_account_limits&quot;,&quot;base&quot;:&quot;&quot;,&quot;fields&quot;:[&#123;&quot;n... 创建账户首先需要为账户创建一个key： 123$ cleos create keyPrivate key: 5JiconQnk5WTpAbX5zcfkgXHhuki6Yy2U2zYKQmL5ovLUKprANNPublic key: EOS6oPBCtWDzeRBxFMHZebxTgHFFybYqurt8GLwMSHabEkZk4tYku 然后把key导入钱包： 12$ cleos wallet import 5JiconQnk5WTpAbX5zcfkgXHhuki6Yy2U2zYKQmL5ovLUKprANN -n mywalletimported private key for: EOS6oPBCtWDzeRBxFMHZebxTgHFFybYqurt8GLwMSHabEkZk4tYku 通过该钱包创建两个账户 tester1 和 tester2 ： 123$ cleos create account eosio tester1 EOS6oPBCtWDzeRBxFMHZebxTgHFFybYqurt8GLwMSHabEkZk4tYku EOS6oPBCtWDzeRBxFMHZebxTgHFFybYqurt8GLwMSHabEkZk4tYkuexecuted transaction: 49b5aad108995ce096a840f2537376ae4cfadc57e06af7b1f435ae4e291991d7 352 bytes 102400 cycles# eosio &lt;&#x3D; eosio::newaccount &#123;&quot;creator&quot;:&quot;eosio&quot;,&quot;name&quot;:&quot;tester1&quot;,&quot;owner&quot;:&#123;&quot;threshold&quot;:1,&quot;keys&quot;:[&#123;&quot;key&quot;:&quot;EOS6oPBCtWDzeRBxFMHZebxTg... 同理，把”tester1”改为”tester2”即可创建 tester2 账户。 一个简单的合约建立一个文件夹命名为hello，并且建立一个hello.cpp文件： 123$ mkdir hello$ cd hello$ touch hello.cpp hello.cpp中输入以下内容： 123456789101112131415#include &lt;eosiolib&#x2F;eosio.hpp&gt;#include &lt;eosiolib&#x2F;print.hpp&gt;using namespace eosio;class hello : public eosio::contract &#123; public: using contract::contract; &#x2F;&#x2F;&#x2F; @abi action void hi( account_name user ) &#123; print( &quot;Hello, &quot;, name&#123;user&#125; ); &#125;&#125;;EOSIO_ABI( hello, (hi) ) 编译出wast和abi文件，过程中可能会出现warning，可以暂时不需要理会： 12$ eosiocpp -o hello.wast hello.cpp$ eosiocpp -g hello.abi hello.cpp 接下来通过下面命令部署合约： 1$ cleos set contract tester1 ..&#x2F;hello -p tester1 现在，我们试着运行一下合约： 1234$ cleos push action tester1 hi &#39;[&quot;tester2&quot;]&#39; -p tester2executed transaction: 28d92256c8ffd8b0255be324e4596b7c745f50f85722d0c4400471bc184b9a16 244 bytes 1000 cycles# tester1 &lt;&#x3D; tester1::hi &#123;&quot;user&quot;:&quot;tester2&quot;&#125;&gt;&gt; Hello, tester2 “-p tester2”表示赋予 tester2 权限。 参考 https://github.com/EOSIO/eos/wiki","categories":[{"name":"攻城狮那些事儿","slug":"攻城狮那些事儿","permalink":"https://damonlau27.github.io/categories/%E6%94%BB%E5%9F%8E%E7%8B%AE%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"}],"tags":[{"name":"Blockchain","slug":"Blockchain","permalink":"https://damonlau27.github.io/tags/Blockchain/"}]},{"title":"EOSIO宪法草案","slug":"EOSIO宪法草案","date":"2018-05-03T12:58:12.000Z","updated":"2018-05-03T12:58:12.000Z","comments":true,"path":"2018/05/03/EOSIO宪法草案/","link":"","permalink":"https://damonlau27.github.io/2018/05/03/EOSIO%E5%AE%AA%E6%B3%95%E8%8D%89%E6%A1%88/","excerpt":"设计原则 第一条–不说谎（EOS用户不得因为利益故意伪造或进行误导性陈述，这种行为将是违宪的并且将是可控告的） 第二条–产权（EOS将是一个有产权定义的区块链或社区，在链上或仲裁程序的范围内简历个人不可侵犯的财产权） 第三条–仲裁（EOS将提供一个“治理区块链”，通过有约束力的仲裁解决纠纷）","text":"设计原则 第一条–不说谎（EOS用户不得因为利益故意伪造或进行误导性陈述，这种行为将是违宪的并且将是可控告的） 第二条–产权（EOS将是一个有产权定义的区块链或社区，在链上或仲裁程序的范围内简历个人不可侵犯的财产权） 第三条–仲裁（EOS将提供一个“治理区块链”，通过有约束力的仲裁解决纠纷） 第四条–选民独立（令牌持有者可以选择块生产者，选民选举必须公平公正，不得因为某些利益而选择不恰当的块生产者） 第五条–无业主或受托人（EOS不属于任何人或任何组织，EOS只忠于EOS宪法） 第六条–10%所以权上限（因为EOS不属于任何人或组织，也为了不被大户控制，任何成员或受益人权益均不得超过已发行代币的10％） 第七条–处罚协议（会员应该同意对于违反宪法的处罚） 第八条–区块生产协议（将会被设计为一个要么同意它要么离开它的协议，记录着会员希望生产者做的事情和不应该做的事情，未同意该协议前不得作为生产者） 第九条–设立仲裁论坛（仲裁员需要在非常严格的约束力下行使权力，并且描述了一个仲裁法庭的组成和被授权审理案件的过程） 第十条–仲裁员标准（成为仲裁员的最低标准） 第十一条–开发人员和智能合同许可（提供智能合约的成员都是开发人员，应通过许可证来提供他们的合约，并且给合约指定一个仲裁法庭） 第十二条–多种语言合同（如有纠纷，多语言合约应指明主导语言，如果作者没有指定，则由处理纠纷的仲裁员选择） 第十三条–负责非会员访问的开发者（由于开发者可以通过他的应用程序向非成员提供服务和链上互动，因此开发者应担全责保证非成员的互动是符合宪法的） 第十四条–没有正面的权利（宪法指出不会为任何成员或成员之间创建积极权利） 第十五条–默认仲裁论坛命名（为没有明确指定仲裁法庭来处理纠纷的合约指定默认仲裁法庭）","categories":[{"name":"攻城狮那些事儿","slug":"攻城狮那些事儿","permalink":"https://damonlau27.github.io/categories/%E6%94%BB%E5%9F%8E%E7%8B%AE%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"}],"tags":[{"name":"Blockchain","slug":"Blockchain","permalink":"https://damonlau27.github.io/tags/Blockchain/"}]},{"title":"Setting Up A Local Environment Of EOS.IO","slug":"Setting-Up-A-Local-Environment-Of-EOS-IO","date":"2018-05-03T01:34:53.000Z","updated":"2018-05-03T01:34:53.000Z","comments":true,"path":"2018/05/03/Setting-Up-A-Local-Environment-Of-EOS-IO/","link":"","permalink":"https://damonlau27.github.io/2018/05/03/Setting-Up-A-Local-Environment-Of-EOS-IO/","excerpt":"eos.io的本地环境的搭建主要是参考eos.io在GitHub的Wiki，同时记录一下搭建过程中遇到的坑。","text":"eos.io的本地环境的搭建主要是参考eos.io在GitHub的Wiki，同时记录一下搭建过程中遇到的坑。 Getting the Code首先需要获得eos.io的source code，通过以下的命令clone到本地：git clone https://github.com/EOSIO/eos --recursive命令行的–recursive这个flag确保克隆eos仓库和它的子模块，如果clone时没有使用这个flag，则通过下面的命令也可以取得子模块：git submodule update --init --recursive Building EOSIOAutomated build script最简单的方法是使用eos的自动编译脚本，自动编译脚本支持以下的系统： 1234561. Amazon 2017.09 and higher.2. Centos 7.3. Fedora 25 and higher (Fedora 27 recommended).4. Mint 18.5. Ubuntu 16.04 (Ubuntu 16.10 recommended).6. MacOS Darwin 10.12 and higher (MacOS 10.13.x recommended). System Requirements (all platforms)同时，所有的操作平台，需要满足： 121. 8GB的可用内存2. 20GB的可用磁盘 如果内存不满足，脚本将会给出提示并且终止当前编译。 Run the build scriptcd eos./eosio_build.sh脚本会check系统的环境，如果某些依赖不存在，脚本会提示进行安装。如下是博主在macOS Darwin 10.13.4上运行脚本后出现的依赖不存在情况： 123456789101112131415161718192021222324252627282930313233343536Checking dependencies.Checking automake ... automake NOT found.Checking Libtool ... Libtool NOT found.Checking OpenSSL ... OpenSSL NOT found.Checking llvm ... llvm NOT found.Checking wget ... wget NOT found.Checking CMake ... CMake NOT found.Checking GMP ... GMP NOT found.Checking gettext ... gettext NOT found.Checking MongoDB ... MongoDB NOT found.Checking Doxygen ... Doxygen NOT found.Checking Graphviz ... Graphviz NOT found.Checking LCOV ... LCOV NOT found.Checking Python3 ... python3 NOT found.The following dependencies are required to install EOSIO.1. automake2. Libtool3. OpenSSL4. llvm5. wget6. CMake7. GMP8. gettext9. MongoDB10. Doxygen11. Graphviz12. LCOV13. Python 3Do you wish to install these packages?1) Yes2) No#? build seccess将会出现以下画面： 123456789101112131415161718192021 _______ _______ _______ _________ _______( ____ \\( ___ )( ____ \\\\__ __&#x2F;( ___ )| ( \\&#x2F;| ( ) || ( \\&#x2F; ) ( | ( ) || (__ | | | || (_____ | | | | | || __) | | | |(_____ ) | | | | | || ( | | | | ) | | | | | | || (____&#x2F;\\| (___) |&#x2F;\\____) |___) (___| (___) |(_______&#x2F;(_______)\\_______)\\_______&#x2F;(_______)EOS.IO has been successfully built. 1:6:15To verify your installation run the following commands:&#x2F;usr&#x2F;local&#x2F;bin&#x2F;mongod -f &#x2F;usr&#x2F;local&#x2F;etc&#x2F;mongod.conf &amp;cd &#x2F;Users&#x2F;lauyearh&#x2F;Blockchain&#x2F;EOS&#x2F;eos&#x2F;build; make testFor more information:EOS.IO website: https:&#x2F;&#x2F;eos.ioEOS.IO Telegram channel @ https:&#x2F;&#x2F;t.me&#x2F;EOSProjectEOS.IO resources: https:&#x2F;&#x2F;eos.io&#x2F;resources&#x2F;EOS.IO wiki: https:&#x2F;&#x2F;github.com&#x2F;EOSIO&#x2F;eos&#x2F;wiki Build validation可以通过一组测试用例，验证你的编译。如果是在Linux平台：~/opt/mongodb/bin/mongod -f ~/opt/mongodb/mongod.conf &amp;如果是在macOS:/usr/local/bin/mongod -f /usr/local/etc/mongod.conf &amp;然后执行以下命令，不管在Linux还是macOS：cd buildmake test最后出现这样的提示说明测试通过： 123100% tests passed, 0 tests failed out of 33Total Test time (real) &#x3D; 806.70 sec Install the executables通过安装可执行档案，可以在系统中方便操作eos，相当于把cmd写到PATH变量中，但是其实是把内容安装到/usr/local：cd buildsudo make install Creating and Launching a Single Node Testnet运行下面的命令，将启动一个简单的节点：cd build/programs/nodeos./nodeos -e -p eosio --plugin eosio::wallet_api_plugin --plugin eosio::chain_api_plugin --plugin eosio::account_history_api_plugin这个时候，默认的config路径，在macOS上是$HOME/Library/Application Support/eosio/nodeos/config，里面包含config.ini和genesis.json两个文件。当然，你也可以在启动nodeos时通过--config-dir指定config路径，并且需要建立ini和json两个文件。 总结博主build时用的是macOS，同时系统配置满足要求，使用自动编译脚本的时候没遇到什么坑，顺利build通过。Source code是master branch，commit id是19227c9b0a095683c1df3668c110cef2d91cbb15。 参考 https://github.com/EOSIO/eos/wiki/Local-Environment","categories":[{"name":"攻城狮那些事儿","slug":"攻城狮那些事儿","permalink":"https://damonlau27.github.io/categories/%E6%94%BB%E5%9F%8E%E7%8B%AE%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"}],"tags":[{"name":"Blockchain","slug":"Blockchain","permalink":"https://damonlau27.github.io/tags/Blockchain/"}]},{"title":"说说以太猫","slug":"说说以太猫","date":"2018-04-27T03:19:43.000Z","updated":"2018-04-27T03:19:43.000Z","comments":true,"path":"2018/04/27/说说以太猫/","link":"","permalink":"https://damonlau27.github.io/2018/04/27/%E8%AF%B4%E8%AF%B4%E4%BB%A5%E5%A4%AA%E7%8C%AB/","excerpt":"随着区块链的热门，基于以太坊的第一个有代表性的游戏项目出现了，这就是CryptoKitties，中文名谜恋猫。","text":"随着区块链的热门，基于以太坊的第一个有代表性的游戏项目出现了，这就是CryptoKitties，中文名谜恋猫。 类似于QQ宠物，谜恋猫需要喂养，可以进行交配并繁育处下一代猫咪。基于256色域作为基因图谱，部署到以太坊上，每一只猫都是独一无二的（颜色、形状等）。谜恋猫最初由背后团队发布500000只作为拍卖，称为初代（GEN 0）猫，然后这些猫交配繁育就会出现GEN 1，GEN 2等。如果你账户下有多只猫，那么可以让他们繁育，然后进行拍卖。当然GEN 0猫是最贵的，一些稀有属性的品种，比如繁育速度快、冷却时间（繁育后需要休息一段时间再进行下一次繁育）短、颜色或形状奇特的猫也是比较贵的，最贵的一只猫卖到了12万美金，真是名副其实的钻石猫。 最开始发布的时候，以太猫的火热程度甚至一度造成以太坊网络的拥堵，而最开始的撸猫党，也是发了一笔横财。天价的猫咪不确定是不是背后团队有炒作，但是不可否认人家没有ICO照样把钱给募了，也许这就是站在风口，猫也会飞。 现在热火慢慢消退，抱着撸猫大发一笔的就要谨慎了。CryptoKitties的官网是https://www.cryptokitties.co，想要开始撸猫日常，需要使用Chrome、Firefox或Brave（区块链浏览器）浏览器，并且可以访问Google应用商店，因为需要安装MateMask，相当于一个浏览器钱包插件，使用这个钱包插件并且登录你的钱包，就可以进行撸猫操作了（当然，你的钱包不能是瘪的，要有以太币或者其他货币，你也可以使用美金买入一些货币）。 最后，撸猫需谨慎，小撸怡情，大撸伤身，强撸灰飞烟灭。","categories":[{"name":"攻城狮那些事儿","slug":"攻城狮那些事儿","permalink":"https://damonlau27.github.io/categories/%E6%94%BB%E5%9F%8E%E7%8B%AE%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"}],"tags":[{"name":"Blockchain","slug":"Blockchain","permalink":"https://damonlau27.github.io/tags/Blockchain/"}]},{"title":"chrome无法访问google而safari可以","slug":"chrome无法访问google而safari可以","date":"2018-04-27T02:35:59.000Z","updated":"2018-04-27T02:35:59.000Z","comments":true,"path":"2018/04/27/chrome无法访问google而safari可以/","link":"","permalink":"https://damonlau27.github.io/2018/04/27/chrome%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AEgoogle%E8%80%8Csafari%E5%8F%AF%E4%BB%A5/","excerpt":"最近在macOS上遇到一个问题，在App Store上安装了一款叫VPN Plus的VPN应用之后，使用Safari确实是可以访问Google和YouTube等网站了，但是用Chrome却无法访问，这是弄啥咧。","text":"最近在macOS上遇到一个问题，在App Store上安装了一款叫VPN Plus的VPN应用之后，使用Safari确实是可以访问Google和YouTube等网站了，但是用Chrome却无法访问，这是弄啥咧。 在网上搜索，有说使用Google的DNS，8.8.8.8或8.8.8.4，有说需要设置Chrome的Https访问，也有说关掉Chrome的QUIC，不过试过之后，这些方法对我的问题都不能解决。然后我把Chrome设为默认浏览器，依然还是不能打开。 后来，我换了一款VPN应用，WiseVPN，居然神奇的Chrome和Safari都能访问了。这是什么原因嘛谁能给我解释一下。 So，如果你也遇到了同样的问题，不妨换一款VPN应用试一下。 最后想说一下，WiseVPN打开网页的速度比VPN Plus要快一些，而且如果你是访问的国内的网站他会识别，不会像连接VPN Plus一样如果你访问百度可能还会打不开。（此处非软文^_^）","categories":[{"name":"随笔","slug":"随笔","permalink":"https://damonlau27.github.io/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[]},{"title":"有关EOS","slug":"有关EOS","date":"2018-04-25T14:56:34.000Z","updated":"2018-04-25T14:56:34.000Z","comments":true,"path":"2018/04/25/有关EOS/","link":"","permalink":"https://damonlau27.github.io/2018/04/25/%E6%9C%89%E5%85%B3EOS/","excerpt":"区块链3.0比特币和以太坊分别是第一代、第二代区块链的代表，而EOS则是第三代区块链中比较有意思的一个，当然超级账本也属于第三代区块链。","text":"区块链3.0比特币和以太坊分别是第一代、第二代区块链的代表，而EOS则是第三代区块链中比较有意思的一个，当然超级账本也属于第三代区块链。以太坊的功能很丰富，但它仍然还是一个PoW系统，能做的仍然有限，目前以太坊最佳的应用就是作为ICO的基础平台，一个用于取代风投的平台。而EOS采用的是DPoS，同时EOS的CTO，Dan正是DPoS的发明者。使用DPoS的EOS每秒大概能处理100万笔交易，这远远大于以太坊每秒大概50多笔的处理交易性能，而且有别于以太坊中，每一笔交易需要消耗一定的Gas，EOS的交易则是完全不用付出资费的。相信EOS逐步稳定之后，将会是区块链3.0中一个有代表性的项目。","categories":[{"name":"攻城狮那些事儿","slug":"攻城狮那些事儿","permalink":"https://damonlau27.github.io/categories/%E6%94%BB%E5%9F%8E%E7%8B%AE%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"}],"tags":[{"name":"Blockchain","slug":"Blockchain","permalink":"https://damonlau27.github.io/tags/Blockchain/"}]},{"title":"打开Ethereum Wallet找不到ipc文件","slug":"打开Ethereum-Wallet找不到ipc文件","date":"2018-04-24T12:54:43.000Z","updated":"2018-04-24T12:54:43.000Z","comments":true,"path":"2018/04/24/打开Ethereum-Wallet找不到ipc文件/","link":"","permalink":"https://damonlau27.github.io/2018/04/24/%E6%89%93%E5%BC%80Ethereum-Wallet%E6%89%BE%E4%B8%8D%E5%88%B0ipc%E6%96%87%E4%BB%B6/","excerpt":"背景介绍在启动Ethereum Wallet之前，不管是通过鼠标双击还是通过命令行启动，如果没有启动节点客户端geth的话，则在启动Ethereum Wallet的时候会默认启动一个geth，该默认geth的datadir在macOS上为$HOME/Library/Ethereum，geth启动的时候会生成一个ipc文件，路径在对应的datadir下，因为Ethereum Wallet通过rpc方式和geth通信。","text":"背景介绍在启动Ethereum Wallet之前，不管是通过鼠标双击还是通过命令行启动，如果没有启动节点客户端geth的话，则在启动Ethereum Wallet的时候会默认启动一个geth，该默认geth的datadir在macOS上为$HOME/Library/Ethereum，geth启动的时候会生成一个ipc文件，路径在对应的datadir下，因为Ethereum Wallet通过rpc方式和geth通信。那么问题来了，如果启动Ethereum Wallet前，手动启动了一个geth，这时候启动Ethereum Wallet的话将不会再启一个geth，并且会去$HOME/Library/Ethereum下找一个ipc文件，那么如果你手动启动的geth使用”–datadir”指定了一个路径，并且该路径不是$HOME/Library/Ethereum，Ethereum Wallet将找不到节点，没法做同步，日子中或控制台将提示$HOME/Library/Ethereum下找不到ipc文件。 解决方法网上有不同的解决方法，下面的是博主在macOS上试过可用的。这里假设手动启动geth时，通过”–datadir”指定的路径是$HOME/Library/Ethereum/ethprivate1，则首先进入Ethereum Wallet的安装目录：cd /Applications/Ethereum Wallet.app/Contents/MacOS然后通过命令启动Ethereum Wallet，并且通过”–rpc”指定ipc文件的路径：./Ethereum\\ Wallet --rpc $HOME/Library/Ethereum/ethprivate1/geth.ipc And the end, good luck to you!","categories":[{"name":"攻城狮那些事儿","slug":"攻城狮那些事儿","permalink":"https://damonlau27.github.io/categories/%E6%94%BB%E5%9F%8E%E7%8B%AE%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"}],"tags":[{"name":"Blockchain","slug":"Blockchain","permalink":"https://damonlau27.github.io/tags/Blockchain/"}]},{"title":"Ethereum私有网络的搭建","slug":"Ethereum私有网络的搭建","date":"2018-04-22T13:46:44.000Z","updated":"2018-04-22T13:46:44.000Z","comments":true,"path":"2018/04/22/Ethereum私有网络的搭建/","link":"","permalink":"https://damonlau27.github.io/2018/04/22/Ethereum%E7%A7%81%E6%9C%89%E7%BD%91%E7%BB%9C%E7%9A%84%E6%90%AD%E5%BB%BA/","excerpt":"以太坊网络以太坊节点网络分为公网、测试网络、私有网络。私有网络是自己搭建的测试网络，类似于一个局域网。以下将通过在macOS上搭建一个私有网络作为示范。","text":"以太坊网络以太坊节点网络分为公网、测试网络、私有网络。私有网络是自己搭建的测试网络，类似于一个局域网。以下将通过在macOS上搭建一个私有网络作为示范。 搭建步骤安装节点客户端首先默认macOS上已经安装了geth客户端 创建创世区块新建一个json文件并命名为genesis.json，然后输入如下内容： 123456789101112131415&#123; &quot;config&quot;: &#123; &quot;chainId&quot;: 15, &quot;homesteadBlock&quot;: 0, &quot;eip155Block&quot;: 0, &quot;eip158Block&quot;: 0 &#125;, &quot;difficulty&quot;: &quot;200000000&quot;, &quot;gasLimit&quot;: &quot;2100000&quot;, &quot;alloc&quot;: &#123; &quot;7df9a875a174b3bc565e6424a0050ebc1b2d1d82&quot;: &#123; &quot;balance&quot;: &quot;300000&quot; &#125;, &quot;f41c74c9ae680c1aa78f42e5647a62f353b7bdde&quot;: &#123; &quot;balance&quot;: &quot;400000&quot; &#125; &#125;&#125; 初始化节点geth --datadir &quot;./&quot; init genesis.json 启动节点geth --datadir &quot;./&quot; --networkid 15 --rpc console --identity &quot;ep1&quot;这样子一个节点就创建并启动了，如果需要创建多个节点，则分别新建目录，并把上面的json文件拷贝过去（同一私有网络创世区块要相同），在每个目录里面执行初始化命令。启动多个节点的时候则需要区分端口号，否则会冲突，但是网络号需要一样，比如在另外两个终端中：geth --datadir &quot;./&quot; --networkid 15 --rpc console --port 30304 --rpcport 8546 --identity &quot;ep2&quot;geth --datadir &quot;./&quot; --networkid 15 --rpc console --port 30305 --rpcport 8547 --identity &quot;ep3&quot;如此下来，就启动了3个节点，分别是ep1、ep2、ep3。 节点互连节点启动的时候，可能只是一个独立的节点，其他节点没有被发现，这时候可以手动添加。首先需要知道节点信息，比如在上面的ep2节点终端中输入 admin.nodeInfo.enode获得该节点的enode信息。接着切到ep1终端，通过 admin.addPeer(刚才那串enode信息)添加节点，添加完后，执行 admin.peers就可以发现ep1已经连接到ep2节点了","categories":[{"name":"攻城狮那些事儿","slug":"攻城狮那些事儿","permalink":"https://damonlau27.github.io/categories/%E6%94%BB%E5%9F%8E%E7%8B%AE%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"}],"tags":[{"name":"Blockchain","slug":"Blockchain","permalink":"https://damonlau27.github.io/tags/Blockchain/"}]},{"title":"《湄公河行动》","slug":"《湄公河行动》","date":"2016-10-15T12:09:13.000Z","updated":"2016-10-15T12:09:13.000Z","comments":true,"path":"2016/10/15/《湄公河行动》/","link":"","permalink":"https://damonlau27.github.io/2016/10/15/%E3%80%8A%E6%B9%84%E5%85%AC%E6%B2%B3%E8%A1%8C%E5%8A%A8%E3%80%8B/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Windows7(64bit) Install Android Studio","slug":"Windows7-64bit-Install-Android-Studio","date":"2016-10-06T04:20:36.000Z","updated":"2016-10-06T04:20:36.000Z","comments":true,"path":"2016/10/06/Windows7-64bit-Install-Android-Studio/","link":"","permalink":"https://damonlau27.github.io/2016/10/06/Windows7-64bit-Install-Android-Studio/","excerpt":"北京：&emsp;&emsp;作为一个Android开发的菜鸟，以前用的都是Eclipse，后来听说Android Studio比Eclipse逼格高，刚好前段时间重装了系统，把以前的软件都卸了，主要还是本着装一下B的精神，这次尝试安装Android Studio玩玩。首先系统是64位的win7，所以下面安装的东西都是基于win7 64bit的。","text":"北京：&emsp;&emsp;作为一个Android开发的菜鸟，以前用的都是Eclipse，后来听说Android Studio比Eclipse逼格高，刚好前段时间重装了系统，把以前的软件都卸了，主要还是本着装一下B的精神，这次尝试安装Android Studio玩玩。首先系统是64位的win7，所以下面安装的东西都是基于win7 64bit的。 步骤： JDK &emsp;&emsp;在正式安装Android Studio前需要先安装JDK。到官网上去下载JDK（如果有墙，自备梯子），这里下载最新的JDK 8u102。下载完成后像安装正常软件一样双击安装，安装完成，可以点击”后续步骤“查看开发文档。 接下来需要配置环境变量。打开”我的电脑-&gt;属性-&gt;高级系统设置-&gt;环境变量”，在系统变量中： 添加JAVA_HOME：安装JDK的目录，我的为”D:\\Program Files\\Java\\jdk1.8.0_102” 添加CLASSPATH：”.;%JAVA_HOME%\\lib\\tools.jar;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\bin;”（注意前面有’.’号） 编辑Path：在前面加上”.;%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin;”（注意前面有’.’号） &emsp;&emsp;配置完在命令行下输入”java -version”，如果出现下面的信息则说明配置正确（务必配置正确，否则Android Studio启动不起来） Android Studio &emsp;&emsp;建议到官网上直接用网页下载，不要用迅雷，至于为什么，听说是避免发生”XCodeGhost“事件。这里下的是最新的android-studio-bundle-145.3276617-windows.exe 下载完成后，双击进行安装，当然可以参考官网的安装教程 &emsp;&emsp;安装完成后，如果电脑没有翻墙，建议先不要勾选Start Android Studio，点击Finish完成安装，然后在安装目录的bin文件夹下找到idea.properties，在后面添加”disable.android.first.run=true”，这是设置打开Android Studio后不联网检测 &emsp;&emsp;第一次打开Android Studio，首先会让你是否导入配置文件，可根据自身情况选择，点击OK，等待安装SDK，安装需要一段时间，耐心等待。安装完成如下 配置SDK环境,点击Configue-&gt;Project Defaults-&gt;Project Structure 配置编码为UTF-8,点击Configue-&gt;Project Defaults-&gt;Settings。And then，开始Android Studio之旅吧 参考： http://blog.csdn.net/zhoujn90/article/details/8957713 http://www.2cto.com/kf/201604/500642.html","categories":[{"name":"攻城狮那些事儿","slug":"攻城狮那些事儿","permalink":"https://damonlau27.github.io/categories/%E6%94%BB%E5%9F%8E%E7%8B%AE%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"}],"tags":[{"name":"android","slug":"android","permalink":"https://damonlau27.github.io/tags/android/"}]},{"title":"《奇幻森林》","slug":"《奇幻森林》","date":"2016-09-24T15:16:57.000Z","updated":"2016-09-24T15:16:57.000Z","comments":true,"path":"2016/09/24/《奇幻森林》/","link":"","permalink":"https://damonlau27.github.io/2016/09/24/%E3%80%8A%E5%A5%87%E5%B9%BB%E6%A3%AE%E6%9E%97%E3%80%8B/","excerpt":"","text":"","categories":[{"name":"电影阅读","slug":"电影阅读","permalink":"https://damonlau27.github.io/categories/%E7%94%B5%E5%BD%B1%E9%98%85%E8%AF%BB/"}],"tags":[]},{"title":"Ubuntu14.04 Install Wine","slug":"Ubuntu14-04-Install-Wine","date":"2016-09-11T02:26:40.000Z","updated":"2016-09-11T02:26:40.000Z","comments":true,"path":"2016/09/11/Ubuntu14-04-Install-Wine/","link":"","permalink":"https://damonlau27.github.io/2016/09/11/Ubuntu14-04-Install-Wine/","excerpt":"What is the winewine(Wine Is Not an Emulator)是一款开源的，免费的Windows程序加速器，能够让多种POSIX-compliant操作系统（如Linux，Mac OSX及BSD等）运行Windows应用程序的兼容层，它不是模拟器，也不是虚拟机，它是运用API转换技术做出Linux和Windows相对应的函数DLL以运行Windows程序。","text":"What is the winewine(Wine Is Not an Emulator)是一款开源的，免费的Windows程序加速器，能够让多种POSIX-compliant操作系统（如Linux，Mac OSX及BSD等）运行Windows应用程序的兼容层，它不是模拟器，也不是虚拟机，它是运用API转换技术做出Linux和Windows相对应的函数DLL以运行Windows程序。 How to installUbuntu安装wine可以通过apt-get install的方式，也可以通过编译源码进行安装。通过apt-get install的方式安装简单快捷（Here），但是通过编译源码安装兼容性和稳定性更好。不喜欢唱歌的屌丝不是好水手，所以下面看看怎么通过编译源码的方式安装wine（如果是64位ubuntu,如果安装不成功可以使用apt-get install的方法，不努力一下怎么知道什么叫绝望呢） 从官网上下载源码包，目前最新的稳定版是1.8.4 下载后解压12tar -jxvf wine-1.8.4.tar.bz2cd wine-1.8.4&#x2F; 打开README可以看到，可以执行./tools/wineinstall进行快速安装或者执行下面的步骤进行安装 不走寻常路，看一下非快速安装，首先执行sudo ./configure检查环境，直到出现”configure: Finished. Do ‘make’ to compile Wine.” 执行make,这一步时间可能有点久，这时候可以喝杯68年中石油，耐心等待 最后出现”Wine build complete.”，那么恭喜你，编译成功了 接着执行make install进行安装 安装完成后，根据README提示，执行winecfg进行配置，打开过程中提示有些东西没有安装，点击install即可 怎么运行程序呢：README中有说明 踩坑日记（执行./configure后的错误和解决方案）： error: Cannot build a 32-bit program, you need to install 32-bit development libraries 1.&#x2F;configure --enable-win64 error: no suitable flex found. Please install the ‘flex’ package 1sudo apt-get install flex error: no suitable bison found. Please install the ‘bison’ package 1sudo apt-get install bison error: X 64-bit development files not found…… 1sudo apt-get install xorg-dev libx11-dev 哪里错误补哪里，麻麻再也不用担心我的学习啦——步步高补错机 So…对于喜欢使用Linux的筒子，总有一个纠结就是很多应用没有Linux版本。有了wine，在Linux上也能执行大多数Windows的程序了，再也不用纠结在Linux和Windows之间切换来切换去了（此处可以有掌声。。。）另外，可以参考wine官网的build过程","categories":[{"name":"攻城狮那些事儿","slug":"攻城狮那些事儿","permalink":"https://damonlau27.github.io/categories/%E6%94%BB%E5%9F%8E%E7%8B%AE%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"}],"tags":[{"name":"wine","slug":"wine","permalink":"https://damonlau27.github.io/tags/wine/"}]},{"title":"《穹顶之下》","slug":"《穹顶之下》","date":"2016-09-10T05:34:32.000Z","updated":"2016-09-10T05:34:32.000Z","comments":true,"path":"2016/09/10/《穹顶之下》/","link":"","permalink":"https://damonlau27.github.io/2016/09/10/%E3%80%8A%E7%A9%B9%E9%A1%B6%E4%B9%8B%E4%B8%8B%E3%80%8B/","excerpt":"","text":"","categories":[{"name":"电影阅读","slug":"电影阅读","permalink":"https://damonlau27.github.io/categories/%E7%94%B5%E5%BD%B1%E9%98%85%E8%AF%BB/"}],"tags":[]},{"title":"《看见》","slug":"《看见》","date":"2016-09-10T05:32:14.000Z","updated":"2016-09-10T05:32:14.000Z","comments":true,"path":"2016/09/10/《看见》/","link":"","permalink":"https://damonlau27.github.io/2016/09/10/%E3%80%8A%E7%9C%8B%E8%A7%81%E3%80%8B/","excerpt":"","text":"作者： 柴静:","categories":[{"name":"电影阅读","slug":"电影阅读","permalink":"https://damonlau27.github.io/categories/%E7%94%B5%E5%BD%B1%E9%98%85%E8%AF%BB/"}],"tags":[]},{"title":"《还没长大就老了》","slug":"《还没长大就老了》","date":"2016-09-10T05:29:19.000Z","updated":"2016-09-10T05:29:19.000Z","comments":true,"path":"2016/09/10/《还没长大就老了》/","link":"","permalink":"https://damonlau27.github.io/2016/09/10/%E3%80%8A%E8%BF%98%E6%B2%A1%E9%95%BF%E5%A4%A7%E5%B0%B1%E8%80%81%E4%BA%86%E3%80%8B/","excerpt":"","text":"作者： 朱冰","categories":[{"name":"电影阅读","slug":"电影阅读","permalink":"https://damonlau27.github.io/categories/%E7%94%B5%E5%BD%B1%E9%98%85%E8%AF%BB/"}],"tags":[]},{"title":"苹果2016秋季发布会","slug":"苹果2016秋季发布会","date":"2016-09-10T01:29:05.000Z","updated":"2016-09-10T01:29:05.000Z","comments":true,"path":"2016/09/10/苹果2016秋季发布会/","link":"","permalink":"https://damonlau27.github.io/2016/09/10/%E8%8B%B9%E6%9E%9C2016%E7%A7%8B%E5%AD%A3%E5%8F%91%E5%B8%83%E4%BC%9A/","excerpt":"Note：以下评论，纯属个人观点 发布会的开始，是库克在车上和另外两个大叔唱歌，看着一脸便秘的库克，尴尬症都犯了，可能是为了接下来演讲苹果的音乐应用做铺垫吧","text":"Note：以下评论，纯属个人观点 发布会的开始，是库克在车上和另外两个大叔唱歌，看着一脸便秘的库克，尴尬症都犯了，可能是为了接下来演讲苹果的音乐应用做铺垫吧 整个发布会大概为：介绍苹果平台上增加和升级的应用；Apple Watch；Iphone；Airpods耳机 App Store里的应用：比较深刻的是超级玛丽奥，现场请来了任天堂的宫本茂。宫大叔讲了几句很日本的英语后，决定请个翻译自己讲回日语(对于看惯了等讲完了再翻译，这个翻译还没等宫大叔讲完，就开始翻译了，好像提前知道宫大叔讲的内容似的赶脚）来张特写更新的超级玛丽奥增加了对战的模式 Apple Watch：个人比较感兴趣的是它的语音和消息提示功能，但据网上所说，Apple Watch的Siri就是个鸡肋。 这次的Watch内置了GPS模块，更方便对于运动轨迹的定位和地图导航。 增加、优化了应用的控制 防水级别从一代的溅水提升到现在的游泳级别 Iphone：看点： 提升防水级别 home键改为固态触感式，用人话说就是其实是按不下去的，但是给你一个按下去的感觉，可能是为了节约空间和防水吧 取消3.5mm耳机插口，改为Lighting接口，原来的耳机可以搭配一个转接口继续使用，不过想一边充电一边听歌，就要看一下深圳华强北有没有这个零件了 7升级广角摄像头，7plus增加一个长焦镜头，也就是双镜头，增加背景模糊化功能（这个国产早就有了，还有更高级的美图、美颜）对于这样的Iphone7网友们好像并不卖帐，发布会还没结束，吐曹会就召开了网友已经开破一切看到这样的吐曹，乔帮主都要气活了 AirPods耳机：这个真不明白和蓝牙有多大区别，不就是无线耳机吗。继Iphone被玩坏后，AirPods也彻底沦陷。还没开卖就用上了（从EarPod到AirPod的锐变）以后的工作就是捡耳机，毕竟一副150美刀这货充电一次可用5小时，关键充电盒子还得另外充电，不带多两个充电宝都不敢出门在不久的将来，请相信万能的某宝将会出现“左耳换右耳 右耳换左耳”的热搜 巴拉巴拉：整个发布会，公布了很多有关数字的，比如App Store的下载量，Iphone卖了多少台，音乐应用的用户有多少，米果人是不是很喜欢用数字说话啊。。。苹果手表搭配了不同的表带，各个表带价格还不一样；iphone提供了不同颜色的款式，这次还搞了个“高级黑”。这些“创新”感觉并不能带来很大的惊喜，说是创新，其实这所谓了创新很多国产手机都走在前面了，可能这对于苹果自己来说是个创新吧。库克也许是个运营好手，但越来越感觉苹果已没有乔帮主时代的工匠精神了（好吧，毕竟库克不在技术这一块），甚至现在开始向Android阵营取经了。这次的发布会可以说不痛不痒，并不能打动很多人的神经。先观望一下，看看网友到手使用后有什么感受再决定要不要入手一部（哥一枚穷屌，哥入手走的是24期分期，贼伤心。。。）","categories":[{"name":"随笔","slug":"随笔","permalink":"https://damonlau27.github.io/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[]},{"title":"一叶轻舟","slug":"一叶轻舟","date":"2016-09-10T00:57:56.000Z","updated":"2016-09-10T00:57:56.000Z","comments":true,"path":"2016/09/10/一叶轻舟/","link":"","permalink":"https://damonlau27.github.io/2016/09/10/%E4%B8%80%E5%8F%B6%E8%BD%BB%E8%88%9F/","excerpt":"死要面子活受罪 September 11, 2016 12:20 AM 月盈则亏 September 11, 2016 12:20 AM","text":"死要面子活受罪 September 11, 2016 12:20 AM 月盈则亏 September 11, 2016 12:20 AM 要做事，先做人 September 10, 2016 10:59 PM 随兴而起，随遇而安 September 10, 2016 9:07 AM","categories":[{"name":"随笔","slug":"随笔","permalink":"https://damonlau27.github.io/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[]},{"title":"MarkDown语法","slug":"MarkDown语法","date":"2016-09-04T07:42:05.000Z","updated":"2016-09-04T07:42:05.000Z","comments":true,"path":"2016/09/04/MarkDown语法/","link":"","permalink":"https://damonlau27.github.io/2016/09/04/MarkDown%E8%AF%AD%E6%B3%95/","excerpt":"结果显示（由于GitHub不支持某些语法，所以有些格式不能显示出来）：一级标题","text":"结果显示（由于GitHub不支持某些语法，所以有些格式不能显示出来）：一级标题 二级标题三级标题四级标题五级标题六级标题加粗 斜体 inline code 1fenced code blockquote Order List Unorder List page break section break sentence break strikethrough ++underline++ task list column column one two ==highlight== @embedding $$math block$$ $$$math inline$$$ [TOC] 链接（百度） ^footnotes_id 对应的md文件：","categories":[{"name":"攻城狮那些事儿","slug":"攻城狮那些事儿","permalink":"https://damonlau27.github.io/categories/%E6%94%BB%E5%9F%8E%E7%8B%AE%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"}],"tags":[{"name":"MarkDown","slug":"MarkDown","permalink":"https://damonlau27.github.io/tags/MarkDown/"}]},{"title":"如何利用GitHub Pages和Hexo快速搭建个人博客","slug":"如何利用GitHub Pages和Hexo快速搭建个人博客","date":"2016-09-03T05:14:17.000Z","updated":"2016-09-03T05:14:17.000Z","comments":true,"path":"2016/09/03/如何利用GitHub Pages和Hexo快速搭建个人博客/","link":"","permalink":"https://damonlau27.github.io/2016/09/03/%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8GitHub%20Pages%E5%92%8CHexo%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","excerpt":"为什么是GitHub Pages：GitHub Pages提供建立静态的站点，非常适合个人主页、博客等不需要太多动态交互、不太需要数据库支持的网站，而且GitHub上有很多模板和主题，不需要太专业的知识就可以快速搭建一个网站，同时可以用Git管理我们的代码，上传到GitHub托管，最主要还是。。。。。。GitHub Pages免费。","text":"为什么是GitHub Pages：GitHub Pages提供建立静态的站点，非常适合个人主页、博客等不需要太多动态交互、不太需要数据库支持的网站，而且GitHub上有很多模板和主题，不需要太专业的知识就可以快速搭建一个网站，同时可以用Git管理我们的代码，上传到GitHub托管，最主要还是。。。。。。GitHub Pages免费。 两种模式： User/Organization 个人或公司站点 每个GitHub账户只能建一个 资源命名必须为：username/username.github.io 远程仓库的master分支被用来构建和发布页面 Project Pages 项目站点 ph-pages分支用于构建和发布页面 多个项目可以建立多个站点 系统环境配置： 安装Git：1sudo apt-get install git 安装Hexo：1sudo npm install -g hexo-cli Note: 安装Hexo出现“this failure might be due to the use of legacy binary node”，执行一下”sudo apt-get install nodejs-legacy“然后重新安装 也可以使用Jekyll，Hexo和Jekyll都是生成静态网页的工具，只是听说Hexo渲染比Jekyll好，主题多、切换方便 搭建步骤：123456mkdir GitHubPagescd GitHubPageshexo init HexoBlogcd HexoBloghexo generatehexo server 此时用浏览器打开http://localhost:4000/可以看到一篇内置的Blog了 Note: hexo generate/g：生成静态文件，会在当前目录下生成一个新的叫做public的文件夹 hexo server/s：启动本地web服务，用于博客的预览 hexo deploy/d：部署博客到远端（比如github, heroku等平台） hexo clean：清理，包括public文件夹 部署到GitHub Pages： 在GitHub上建立站点： 配置本地站点的_config.yml： 部署到GitHub Pages： 12cd GitHubPages&#x2F;HexoBloghexo d 踩坑提醒：需要提前安装一个扩展：npm install hexo-deployer-git –save 部署成功如下，此时在浏览器输入http://lucienlau.github.io可以访问页面了 新建博客：1hexo new &quot;blogName&quot; Note:这种方式建立的页面会显示在主页上，新建博客文章也是用的这种方式，默认会在站点的source/_post目录下生成”blogName.md”文件 1hexo new page &quot;pageName&quot; Note:这种方式建立的是一个新的页面，会在站点source文件夹下生成一个”pageName”文件夹，可以用这种方式建立一个新的”about”页面，然后把about链接链到这里 MarkDown编辑器：这种方式搭建的博客，很多时候都是用markdown写博文，这里介绍两款比较好用的markdown编辑器 haroopad：左边编辑右边预览，有markdown语法的提示，支持Windows、Linux、Mac等平台，这篇博文就是用haroopad完成的 StackEdit：一款在线的markdown编辑器，有markdown语法提示，能导出为pdf、md、html格式文件，支持同步到google drive 主题设置：hexo init生成的默认主题是landscape，以设置yilia主题为例（更多主题）： 主题下载：1git clone https:&#x2F;&#x2F;github.com&#x2F;litten&#x2F;hexo-theme-yilia.git themes&#x2F;yilia 配置：打开站点下的_config.yml文件，找到theme标签，改为yilia Note:yilia主题issue请看这里 文章摘要：在需要显示摘要的地方添加： 123以上是摘要&lt;!--more--&gt;以下是余下全文 more以上是文章摘要，在主页显示，more以下内容点击”more”链接才显示（如果不添加摘要，主页将会显示文章的全部内容） 网站图标：制作一个ico图标，命名为favicon.ico并放到工程根目录即站点source目录下。可以在Faviconer制作ico图标，国内有比特虫 域名绑定： 打开终端，ping lucienlau.github.io，得到ip 申请域名并添加域名解析，记录类型选择A，记录值填刚得到的ip 在站点source文件夹下建立CNAME文件，写上自己的域名，然后部署到GitHub Pages 几分钟后，应该可以通过自己的域名访问博客了 设置自己的评论系统：由于这是静态网站，评论系统需要用第三方的，以多说为例： 注册多说并安装 打开主题下的_config.yml配置文件，找到”duoshuo”标签，改为”test1”，原来的可能是”true”，其实不是”true”或”false”，是作者的就叫”true” 网站访问统计：评论有“多说”，计数有“不蒜”。不蒜子目前还没开放注册，不过仍然可以使用，只需两行代码。比如要在页脚靠左显示访问情况，则修改主题下的layout/_partial/footer.ejs文件（更多设置） 设置博客音乐： 登录网易云音乐web版，选择歌曲并按提示生成外链（有的歌有版权，不能生成外链，想选一首周杰伦的，发现由于有版权保护不能生成外链） 选择需要插入的位置，比如页脚靠右，则修改主题下的layout/_partial/footer.ejs 使用图床：图床其实就是存放图片等的地方，GitHub提供的空间有限，可以把一些图片等放到别的地方，以七牛云为例，注册七牛云，上传图片，七牛云会为每张图片提供一个外链，然后在需要显示图片的地方插入链接即可 参考链接： http://sunwhut.com/2015/10/30/buildBlog/ http://jiji262.github.io/2016/04/15/2016-04-15-hexo-github-pages-blog/ http://ibruce.info/2013/11/22/hexo-your-blog/ http://fupinyou.com/2016/02/19/%E4%BD%BF%E7%94%A8hexo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/ http://blog.csdn.net/hitwhylz/article/details/42646197 http://www.cnblogs.com/purediy/archive/2013/03/07/2948892.html","categories":[{"name":"攻城狮那些事儿","slug":"攻城狮那些事儿","permalink":"https://damonlau27.github.io/categories/%E6%94%BB%E5%9F%8E%E7%8B%AE%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://damonlau27.github.io/tags/Hexo/"},{"name":"yilia","slug":"yilia","permalink":"https://damonlau27.github.io/tags/yilia/"}]}],"categories":[{"name":"攻城狮那些事儿","slug":"攻城狮那些事儿","permalink":"https://damonlau27.github.io/categories/%E6%94%BB%E5%9F%8E%E7%8B%AE%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"},{"name":"电影阅读","slug":"电影阅读","permalink":"https://damonlau27.github.io/categories/%E7%94%B5%E5%BD%B1%E9%98%85%E8%AF%BB/"},{"name":"随笔","slug":"随笔","permalink":"https://damonlau27.github.io/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"读书","slug":"读书","permalink":"https://damonlau27.github.io/tags/%E8%AF%BB%E4%B9%A6/"},{"name":"Golang","slug":"Golang","permalink":"https://damonlau27.github.io/tags/Golang/"},{"name":"eosio","slug":"eosio","permalink":"https://damonlau27.github.io/tags/eosio/"},{"name":"macOS","slug":"macOS","permalink":"https://damonlau27.github.io/tags/macOS/"},{"name":"HomeBrew","slug":"HomeBrew","permalink":"https://damonlau27.github.io/tags/HomeBrew/"},{"name":"React","slug":"React","permalink":"https://damonlau27.github.io/tags/React/"},{"name":"Blockchain","slug":"Blockchain","permalink":"https://damonlau27.github.io/tags/Blockchain/"},{"name":"android","slug":"android","permalink":"https://damonlau27.github.io/tags/android/"},{"name":"wine","slug":"wine","permalink":"https://damonlau27.github.io/tags/wine/"},{"name":"MarkDown","slug":"MarkDown","permalink":"https://damonlau27.github.io/tags/MarkDown/"},{"name":"Hexo","slug":"Hexo","permalink":"https://damonlau27.github.io/tags/Hexo/"},{"name":"yilia","slug":"yilia","permalink":"https://damonlau27.github.io/tags/yilia/"}]}